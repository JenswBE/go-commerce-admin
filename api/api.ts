/* tslint:disable */
/* eslint-disable */
/**
 * GoCommerce
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof Category
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    description?: string;
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof Category
     */
    parent_id?: string;
    /**
     * Should be sorted ascending by this column
     * @type {number}
     * @memberof Category
     */
    order: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Category
     */
    product_ids?: Array<string>;
    /**
     * Signed URL pointing to the image
     * @type {string}
     * @memberof Category
     */
    image_url?: string;
}
/**
 * 
 * @export
 * @interface CategoryAllOf
 */
export interface CategoryAllOf {
    /**
     * 
     * @type {string}
     * @memberof CategoryAllOf
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryAllOf
     */
    description?: string;
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof CategoryAllOf
     */
    parent_id?: string;
    /**
     * Should be sorted ascending by this column
     * @type {number}
     * @memberof CategoryAllOf
     */
    order: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CategoryAllOf
     */
    product_ids?: Array<string>;
    /**
     * Signed URL pointing to the image
     * @type {string}
     * @memberof CategoryAllOf
     */
    image_url?: string;
}
/**
 * 
 * @export
 * @interface CategoryList
 */
export interface CategoryList {
    /**
     * 
     * @type {Array<Category>}
     * @memberof CategoryList
     */
    categories: Array<Category>;
}
/**
 * 
 * @export
 * @interface Header
 */
export interface Header {
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof Header
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface HeaderTimestamped
 */
export interface HeaderTimestamped {
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof HeaderTimestamped
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof HeaderTimestamped
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof HeaderTimestamped
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface HeaderTimestampedAllOf
 */
export interface HeaderTimestampedAllOf {
    /**
     * 
     * @type {string}
     * @memberof HeaderTimestampedAllOf
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof HeaderTimestampedAllOf
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    id: string;
    /**
     * Extension of the image
     * @type {string}
     * @memberof Image
     */
    ext: string;
    /**
     * Signed URL pointing to the image
     * @type {string}
     * @memberof Image
     */
    url: string;
    /**
     * Should be sorted ascending by this column
     * @type {number}
     * @memberof Image
     */
    order: number;
}
/**
 * 
 * @export
 * @interface ImageList
 */
export interface ImageList {
    /**
     * 
     * @type {Array<Image>}
     * @memberof ImageList
     */
    images: Array<Image>;
}
/**
 * 
 * @export
 * @interface Manufacturer
 */
export interface Manufacturer {
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof Manufacturer
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Manufacturer
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Manufacturer
     */
    website_url?: string;
    /**
     * Signed URL pointing to the image
     * @type {string}
     * @memberof Manufacturer
     */
    image_url?: string;
}
/**
 * 
 * @export
 * @interface ManufacturerAllOf
 */
export interface ManufacturerAllOf {
    /**
     * 
     * @type {string}
     * @memberof ManufacturerAllOf
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ManufacturerAllOf
     */
    website_url?: string;
    /**
     * Signed URL pointing to the image
     * @type {string}
     * @memberof ManufacturerAllOf
     */
    image_url?: string;
}
/**
 * 
 * @export
 * @interface ManufacturerList
 */
export interface ManufacturerList {
    /**
     * 
     * @type {Array<Manufacturer>}
     * @memberof ManufacturerList
     */
    manufacturers: Array<Manufacturer>;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof Product
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    description_short?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    description_long?: string;
    /**
     * Price in cents
     * @type {number}
     * @memberof Product
     */
    price: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Product
     */
    category_ids?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    manufacturer_id?: string;
    /**
     * 
     * @type {ProductStatus}
     * @memberof Product
     */
    status?: ProductStatus;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    stock_count?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Product
     */
    image_urls?: Array<string>;
}
/**
 * 
 * @export
 * @interface ProductAllOf
 */
export interface ProductAllOf {
    /**
     * 
     * @type {string}
     * @memberof ProductAllOf
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ProductAllOf
     */
    description_short?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductAllOf
     */
    description_long?: string;
    /**
     * Price in cents
     * @type {number}
     * @memberof ProductAllOf
     */
    price: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductAllOf
     */
    category_ids?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ProductAllOf
     */
    manufacturer_id?: string;
    /**
     * 
     * @type {ProductStatus}
     * @memberof ProductAllOf
     */
    status?: ProductStatus;
    /**
     * 
     * @type {number}
     * @memberof ProductAllOf
     */
    stock_count?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductAllOf
     */
    image_urls?: Array<string>;
}
/**
 * 
 * @export
 * @interface ProductList
 */
export interface ProductList {
    /**
     * 
     * @type {Array<Product>}
     * @memberof ProductList
     */
    products: Array<Product>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ProductStatus {
    Available = 'AVAILABLE',
    Archived = 'ARCHIVED'
}

/**
 * 
 * @export
 * @interface ProductWithManufacturer
 */
export interface ProductWithManufacturer {
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof ProductWithManufacturer
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductWithManufacturer
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductWithManufacturer
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductWithManufacturer
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ProductWithManufacturer
     */
    description_short?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductWithManufacturer
     */
    description_long?: string;
    /**
     * Price in cents
     * @type {number}
     * @memberof ProductWithManufacturer
     */
    price: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductWithManufacturer
     */
    category_ids?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ProductWithManufacturer
     */
    manufacturer_id?: string;
    /**
     * 
     * @type {ProductStatus}
     * @memberof ProductWithManufacturer
     */
    status?: ProductStatus;
    /**
     * 
     * @type {number}
     * @memberof ProductWithManufacturer
     */
    stock_count?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductWithManufacturer
     */
    image_urls?: Array<string>;
    /**
     * 
     * @type {Manufacturer}
     * @memberof ProductWithManufacturer
     */
    manufacturer?: Manufacturer;
}
/**
 * 
 * @export
 * @interface ProductWithManufacturerAllOf
 */
export interface ProductWithManufacturerAllOf {
    /**
     * 
     * @type {Manufacturer}
     * @memberof ProductWithManufacturerAllOf
     */
    manufacturer?: Manufacturer;
}

/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add category
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAddCategory: async (category: Category, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'category' is not null or undefined
            assertParamExists('adminAddCategory', 'category', category)
            const localVarPath = `/admin/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(category, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete category
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteCategory: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminDeleteCategory', 'id', id)
            const localVarPath = `/admin/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete image
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteCategoryImage: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminDeleteCategoryImage', 'id', id)
            const localVarPath = `/admin/categories/{id}/image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get category details
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetCategory: async (id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminGetCategory', 'id', id)
            const localVarPath = `/admin/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (imgH !== undefined) {
                localVarQueryParameter['img_h'] = imgH;
            }

            if (imgR !== undefined) {
                localVarQueryParameter['img_r'] = imgR;
            }

            if (imgW !== undefined) {
                localVarQueryParameter['img_w'] = imgW;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List categories
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminListCategories: async (imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (imgH !== undefined) {
                localVarQueryParameter['img_h'] = imgH;
            }

            if (imgR !== undefined) {
                localVarQueryParameter['img_r'] = imgR;
            }

            if (imgW !== undefined) {
                localVarQueryParameter['img_w'] = imgW;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update category
         * @param {string} id ID
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateCategory: async (id: string, category: Category, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminUpdateCategory', 'id', id)
            // verify required parameter 'category' is not null or undefined
            assertParamExists('adminUpdateCategory', 'category', category)
            const localVarPath = `/admin/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(category, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upsert image
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpsertCategoryImage: async (id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, file?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminUpsertCategoryImage', 'id', id)
            const localVarPath = `/admin/categories/{id}/image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (imgH !== undefined) {
                localVarQueryParameter['img_h'] = imgH;
            }

            if (imgR !== undefined) {
                localVarQueryParameter['img_r'] = imgR;
            }

            if (imgW !== undefined) {
                localVarQueryParameter['img_w'] = imgW;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get category details
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicGetCategory: async (id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('publicGetCategory', 'id', id)
            const localVarPath = `/public/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (imgH !== undefined) {
                localVarQueryParameter['img_h'] = imgH;
            }

            if (imgR !== undefined) {
                localVarQueryParameter['img_r'] = imgR;
            }

            if (imgW !== undefined) {
                localVarQueryParameter['img_w'] = imgW;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List categories
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicListCategories: async (imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (imgH !== undefined) {
                localVarQueryParameter['img_h'] = imgH;
            }

            if (imgR !== undefined) {
                localVarQueryParameter['img_r'] = imgR;
            }

            if (imgW !== undefined) {
                localVarQueryParameter['img_w'] = imgW;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Add category
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminAddCategory(category: Category, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminAddCategory(category, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete category
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteCategory(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteCategory(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete image
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteCategoryImage(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteCategoryImage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get category details
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminGetCategory(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetCategory(id, imgH, imgR, imgW, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List categories
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminListCategories(imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminListCategories(imgH, imgR, imgW, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update category
         * @param {string} id ID
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateCategory(id: string, category: Category, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateCategory(id, category, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upsert image
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpsertCategoryImage(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpsertCategoryImage(id, imgH, imgR, imgW, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get category details
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicGetCategory(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicGetCategory(id, imgH, imgR, imgW, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List categories
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicListCategories(imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicListCategories(imgH, imgR, imgW, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoriesApiFp(configuration)
    return {
        /**
         * Add category
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAddCategory(category: Category, options?: any): AxiosPromise<Category> {
            return localVarFp.adminAddCategory(category, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete category
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteCategory(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.adminDeleteCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete image
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteCategoryImage(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.adminDeleteCategoryImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get category details
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetCategory(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): AxiosPromise<Category> {
            return localVarFp.adminGetCategory(id, imgH, imgR, imgW, options).then((request) => request(axios, basePath));
        },
        /**
         * List categories
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminListCategories(imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): AxiosPromise<CategoryList> {
            return localVarFp.adminListCategories(imgH, imgR, imgW, options).then((request) => request(axios, basePath));
        },
        /**
         * Update category
         * @param {string} id ID
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateCategory(id: string, category: Category, options?: any): AxiosPromise<Category> {
            return localVarFp.adminUpdateCategory(id, category, options).then((request) => request(axios, basePath));
        },
        /**
         * Upsert image
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpsertCategoryImage(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, file?: any, options?: any): AxiosPromise<Image> {
            return localVarFp.adminUpsertCategoryImage(id, imgH, imgR, imgW, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Get category details
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicGetCategory(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): AxiosPromise<Category> {
            return localVarFp.publicGetCategory(id, imgH, imgR, imgW, options).then((request) => request(axios, basePath));
        },
        /**
         * List categories
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicListCategories(imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): AxiosPromise<CategoryList> {
            return localVarFp.publicListCategories(imgH, imgR, imgW, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
    /**
     * Add category
     * @param {Category} category 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public adminAddCategory(category: Category, options?: any) {
        return CategoriesApiFp(this.configuration).adminAddCategory(category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete category
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public adminDeleteCategory(id: string, options?: any) {
        return CategoriesApiFp(this.configuration).adminDeleteCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete image
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public adminDeleteCategoryImage(id: string, options?: any) {
        return CategoriesApiFp(this.configuration).adminDeleteCategoryImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get category details
     * @param {string} id ID
     * @param {number} [imgH] Image height
     * @param {'FILL' | 'FIT'} [imgR] Image resize mode
     * @param {number} [imgW] Image width
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public adminGetCategory(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any) {
        return CategoriesApiFp(this.configuration).adminGetCategory(id, imgH, imgR, imgW, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List categories
     * @param {number} [imgH] Image height
     * @param {'FILL' | 'FIT'} [imgR] Image resize mode
     * @param {number} [imgW] Image width
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public adminListCategories(imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any) {
        return CategoriesApiFp(this.configuration).adminListCategories(imgH, imgR, imgW, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update category
     * @param {string} id ID
     * @param {Category} category 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public adminUpdateCategory(id: string, category: Category, options?: any) {
        return CategoriesApiFp(this.configuration).adminUpdateCategory(id, category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upsert image
     * @param {string} id ID
     * @param {number} [imgH] Image height
     * @param {'FILL' | 'FIT'} [imgR] Image resize mode
     * @param {number} [imgW] Image width
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public adminUpsertCategoryImage(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, file?: any, options?: any) {
        return CategoriesApiFp(this.configuration).adminUpsertCategoryImage(id, imgH, imgR, imgW, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get category details
     * @param {string} id ID
     * @param {number} [imgH] Image height
     * @param {'FILL' | 'FIT'} [imgR] Image resize mode
     * @param {number} [imgW] Image width
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public publicGetCategory(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any) {
        return CategoriesApiFp(this.configuration).publicGetCategory(id, imgH, imgR, imgW, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List categories
     * @param {number} [imgH] Image height
     * @param {'FILL' | 'FIT'} [imgR] Image resize mode
     * @param {number} [imgW] Image width
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public publicListCategories(imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any) {
        return CategoriesApiFp(this.configuration).publicListCategories(imgH, imgR, imgW, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ManufacturersApi - axios parameter creator
 * @export
 */
export const ManufacturersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add manufacturer
         * @param {Manufacturer} manufacturer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAddManufacturer: async (manufacturer: Manufacturer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'manufacturer' is not null or undefined
            assertParamExists('adminAddManufacturer', 'manufacturer', manufacturer)
            const localVarPath = `/admin/manufacturers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manufacturer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete manufacturer
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteManufacturer: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminDeleteManufacturer', 'id', id)
            const localVarPath = `/admin/manufacturers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete image
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteManufacturerImage: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminDeleteManufacturerImage', 'id', id)
            const localVarPath = `/admin/manufacturers/{id}/image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get manufacturer details
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetManufacturer: async (id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminGetManufacturer', 'id', id)
            const localVarPath = `/admin/manufacturers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (imgH !== undefined) {
                localVarQueryParameter['img_h'] = imgH;
            }

            if (imgR !== undefined) {
                localVarQueryParameter['img_r'] = imgR;
            }

            if (imgW !== undefined) {
                localVarQueryParameter['img_w'] = imgW;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List manufacturers
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminListManufacturers: async (imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/manufacturers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (imgH !== undefined) {
                localVarQueryParameter['img_h'] = imgH;
            }

            if (imgR !== undefined) {
                localVarQueryParameter['img_r'] = imgR;
            }

            if (imgW !== undefined) {
                localVarQueryParameter['img_w'] = imgW;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update manufacturer
         * @param {string} id ID
         * @param {Manufacturer} manufacturer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateManufacturer: async (id: string, manufacturer: Manufacturer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminUpdateManufacturer', 'id', id)
            // verify required parameter 'manufacturer' is not null or undefined
            assertParamExists('adminUpdateManufacturer', 'manufacturer', manufacturer)
            const localVarPath = `/admin/manufacturers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manufacturer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upsert image
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpsertManufacturerImage: async (id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, file?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminUpsertManufacturerImage', 'id', id)
            const localVarPath = `/admin/manufacturers/{id}/image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (imgH !== undefined) {
                localVarQueryParameter['img_h'] = imgH;
            }

            if (imgR !== undefined) {
                localVarQueryParameter['img_r'] = imgR;
            }

            if (imgW !== undefined) {
                localVarQueryParameter['img_w'] = imgW;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get manufacturer details
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicGetManufacturer: async (id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('publicGetManufacturer', 'id', id)
            const localVarPath = `/public/manufacturers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (imgH !== undefined) {
                localVarQueryParameter['img_h'] = imgH;
            }

            if (imgR !== undefined) {
                localVarQueryParameter['img_r'] = imgR;
            }

            if (imgW !== undefined) {
                localVarQueryParameter['img_w'] = imgW;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List manufacturers
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicListManufacturers: async (imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/manufacturers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (imgH !== undefined) {
                localVarQueryParameter['img_h'] = imgH;
            }

            if (imgR !== undefined) {
                localVarQueryParameter['img_r'] = imgR;
            }

            if (imgW !== undefined) {
                localVarQueryParameter['img_w'] = imgW;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManufacturersApi - functional programming interface
 * @export
 */
export const ManufacturersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManufacturersApiAxiosParamCreator(configuration)
    return {
        /**
         * Add manufacturer
         * @param {Manufacturer} manufacturer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminAddManufacturer(manufacturer: Manufacturer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminAddManufacturer(manufacturer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete manufacturer
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteManufacturer(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteManufacturer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete image
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteManufacturerImage(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteManufacturerImage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get manufacturer details
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminGetManufacturer(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetManufacturer(id, imgH, imgR, imgW, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List manufacturers
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminListManufacturers(imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManufacturerList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminListManufacturers(imgH, imgR, imgW, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update manufacturer
         * @param {string} id ID
         * @param {Manufacturer} manufacturer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateManufacturer(id: string, manufacturer: Manufacturer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateManufacturer(id, manufacturer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upsert image
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpsertManufacturerImage(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpsertManufacturerImage(id, imgH, imgR, imgW, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get manufacturer details
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicGetManufacturer(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicGetManufacturer(id, imgH, imgR, imgW, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List manufacturers
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicListManufacturers(imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManufacturerList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicListManufacturers(imgH, imgR, imgW, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ManufacturersApi - factory interface
 * @export
 */
export const ManufacturersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManufacturersApiFp(configuration)
    return {
        /**
         * Add manufacturer
         * @param {Manufacturer} manufacturer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAddManufacturer(manufacturer: Manufacturer, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.adminAddManufacturer(manufacturer, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete manufacturer
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteManufacturer(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.adminDeleteManufacturer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete image
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteManufacturerImage(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.adminDeleteManufacturerImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get manufacturer details
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetManufacturer(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.adminGetManufacturer(id, imgH, imgR, imgW, options).then((request) => request(axios, basePath));
        },
        /**
         * List manufacturers
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminListManufacturers(imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): AxiosPromise<ManufacturerList> {
            return localVarFp.adminListManufacturers(imgH, imgR, imgW, options).then((request) => request(axios, basePath));
        },
        /**
         * Update manufacturer
         * @param {string} id ID
         * @param {Manufacturer} manufacturer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateManufacturer(id: string, manufacturer: Manufacturer, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.adminUpdateManufacturer(id, manufacturer, options).then((request) => request(axios, basePath));
        },
        /**
         * Upsert image
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpsertManufacturerImage(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, file?: any, options?: any): AxiosPromise<Image> {
            return localVarFp.adminUpsertManufacturerImage(id, imgH, imgR, imgW, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Get manufacturer details
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicGetManufacturer(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.publicGetManufacturer(id, imgH, imgR, imgW, options).then((request) => request(axios, basePath));
        },
        /**
         * List manufacturers
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicListManufacturers(imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): AxiosPromise<ManufacturerList> {
            return localVarFp.publicListManufacturers(imgH, imgR, imgW, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManufacturersApi - object-oriented interface
 * @export
 * @class ManufacturersApi
 * @extends {BaseAPI}
 */
export class ManufacturersApi extends BaseAPI {
    /**
     * Add manufacturer
     * @param {Manufacturer} manufacturer 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public adminAddManufacturer(manufacturer: Manufacturer, options?: any) {
        return ManufacturersApiFp(this.configuration).adminAddManufacturer(manufacturer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete manufacturer
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public adminDeleteManufacturer(id: string, options?: any) {
        return ManufacturersApiFp(this.configuration).adminDeleteManufacturer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete image
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public adminDeleteManufacturerImage(id: string, options?: any) {
        return ManufacturersApiFp(this.configuration).adminDeleteManufacturerImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get manufacturer details
     * @param {string} id ID
     * @param {number} [imgH] Image height
     * @param {'FILL' | 'FIT'} [imgR] Image resize mode
     * @param {number} [imgW] Image width
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public adminGetManufacturer(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any) {
        return ManufacturersApiFp(this.configuration).adminGetManufacturer(id, imgH, imgR, imgW, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List manufacturers
     * @param {number} [imgH] Image height
     * @param {'FILL' | 'FIT'} [imgR] Image resize mode
     * @param {number} [imgW] Image width
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public adminListManufacturers(imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any) {
        return ManufacturersApiFp(this.configuration).adminListManufacturers(imgH, imgR, imgW, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update manufacturer
     * @param {string} id ID
     * @param {Manufacturer} manufacturer 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public adminUpdateManufacturer(id: string, manufacturer: Manufacturer, options?: any) {
        return ManufacturersApiFp(this.configuration).adminUpdateManufacturer(id, manufacturer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upsert image
     * @param {string} id ID
     * @param {number} [imgH] Image height
     * @param {'FILL' | 'FIT'} [imgR] Image resize mode
     * @param {number} [imgW] Image width
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public adminUpsertManufacturerImage(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, file?: any, options?: any) {
        return ManufacturersApiFp(this.configuration).adminUpsertManufacturerImage(id, imgH, imgR, imgW, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get manufacturer details
     * @param {string} id ID
     * @param {number} [imgH] Image height
     * @param {'FILL' | 'FIT'} [imgR] Image resize mode
     * @param {number} [imgW] Image width
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public publicGetManufacturer(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any) {
        return ManufacturersApiFp(this.configuration).publicGetManufacturer(id, imgH, imgR, imgW, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List manufacturers
     * @param {number} [imgH] Image height
     * @param {'FILL' | 'FIT'} [imgR] Image resize mode
     * @param {number} [imgW] Image width
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public publicListManufacturers(imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any) {
        return ManufacturersApiFp(this.configuration).publicListManufacturers(imgH, imgR, imgW, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add product
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAddProduct: async (product: Product, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'product' is not null or undefined
            assertParamExists('adminAddProduct', 'product', product)
            const localVarPath = `/admin/products/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(product, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add product images
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {Array<any>} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAddProductImages: async (id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, file?: Array<any>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminAddProductImages', 'id', id)
            const localVarPath = `/admin/products/{id}/images`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (imgH !== undefined) {
                localVarQueryParameter['img_h'] = imgH;
            }

            if (imgR !== undefined) {
                localVarQueryParameter['img_r'] = imgR;
            }

            if (imgW !== undefined) {
                localVarQueryParameter['img_w'] = imgW;
            }

            if (file) {
                file.forEach((element) => {
                    localVarFormParams.append('file', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete product
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteProduct: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminDeleteProduct', 'id', id)
            const localVarPath = `/admin/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete product image
         * @param {string} id ID
         * @param {string} imageId Image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteProductImage: async (id: string, imageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminDeleteProductImage', 'id', id)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('adminDeleteProductImage', 'imageId', imageId)
            const localVarPath = `/admin/products/{id}/images/{image_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get product details
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetProduct: async (id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminGetProduct', 'id', id)
            const localVarPath = `/admin/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (imgH !== undefined) {
                localVarQueryParameter['img_h'] = imgH;
            }

            if (imgR !== undefined) {
                localVarQueryParameter['img_r'] = imgR;
            }

            if (imgW !== undefined) {
                localVarQueryParameter['img_w'] = imgW;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get product images
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminListProductImages: async (id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminListProductImages', 'id', id)
            const localVarPath = `/admin/products/{id}/images`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (imgH !== undefined) {
                localVarQueryParameter['img_h'] = imgH;
            }

            if (imgR !== undefined) {
                localVarQueryParameter['img_r'] = imgR;
            }

            if (imgW !== undefined) {
                localVarQueryParameter['img_w'] = imgW;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List products
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminListProducts: async (imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/products/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (imgH !== undefined) {
                localVarQueryParameter['img_h'] = imgH;
            }

            if (imgR !== undefined) {
                localVarQueryParameter['img_r'] = imgR;
            }

            if (imgW !== undefined) {
                localVarQueryParameter['img_w'] = imgW;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update product
         * @param {string} id ID
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateProduct: async (id: string, product: Product, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminUpdateProduct', 'id', id)
            // verify required parameter 'product' is not null or undefined
            assertParamExists('adminUpdateProduct', 'product', product)
            const localVarPath = `/admin/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(product, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update product image. In case the new order matches another image, the orders are swapped. Therefore, this call will return all impacted images (1 or 2). First the image on which the request was called and optionally second the swapped image.
         * @param {string} id ID
         * @param {string} imageId Image ID
         * @param {Image} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateProductImage: async (id: string, imageId: string, image: Image, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminUpdateProductImage', 'id', id)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('adminUpdateProductImage', 'imageId', imageId)
            // verify required parameter 'image' is not null or undefined
            assertParamExists('adminUpdateProductImage', 'image', image)
            const localVarPath = `/admin/products/{id}/images/{image_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(image, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get product details
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicGetProduct: async (id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('publicGetProduct', 'id', id)
            const localVarPath = `/public/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (imgH !== undefined) {
                localVarQueryParameter['img_h'] = imgH;
            }

            if (imgR !== undefined) {
                localVarQueryParameter['img_r'] = imgR;
            }

            if (imgW !== undefined) {
                localVarQueryParameter['img_w'] = imgW;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List products
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicListProducts: async (imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/products/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (imgH !== undefined) {
                localVarQueryParameter['img_h'] = imgH;
            }

            if (imgR !== undefined) {
                localVarQueryParameter['img_r'] = imgR;
            }

            if (imgW !== undefined) {
                localVarQueryParameter['img_w'] = imgW;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add product
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminAddProduct(product: Product, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminAddProduct(product, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add product images
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {Array<any>} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminAddProductImages(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, file?: Array<any>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminAddProductImages(id, imgH, imgR, imgW, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete product
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteProduct(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteProduct(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete product image
         * @param {string} id ID
         * @param {string} imageId Image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteProductImage(id: string, imageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteProductImage(id, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get product details
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminGetProduct(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductWithManufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetProduct(id, imgH, imgR, imgW, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get product images
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminListProductImages(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminListProductImages(id, imgH, imgR, imgW, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List products
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminListProducts(imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminListProducts(imgH, imgR, imgW, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update product
         * @param {string} id ID
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateProduct(id: string, product: Product, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateProduct(id, product, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update product image. In case the new order matches another image, the orders are swapped. Therefore, this call will return all impacted images (1 or 2). First the image on which the request was called and optionally second the swapped image.
         * @param {string} id ID
         * @param {string} imageId Image ID
         * @param {Image} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateProductImage(id: string, imageId: string, image: Image, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateProductImage(id, imageId, image, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get product details
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicGetProduct(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductWithManufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicGetProduct(id, imgH, imgR, imgW, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List products
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicListProducts(imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicListProducts(imgH, imgR, imgW, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * Add product
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAddProduct(product: Product, options?: any): AxiosPromise<Product> {
            return localVarFp.adminAddProduct(product, options).then((request) => request(axios, basePath));
        },
        /**
         * Add product images
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {Array<any>} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAddProductImages(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, file?: Array<any>, options?: any): AxiosPromise<ImageList> {
            return localVarFp.adminAddProductImages(id, imgH, imgR, imgW, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete product
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteProduct(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.adminDeleteProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete product image
         * @param {string} id ID
         * @param {string} imageId Image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteProductImage(id: string, imageId: string, options?: any): AxiosPromise<void> {
            return localVarFp.adminDeleteProductImage(id, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get product details
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetProduct(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): AxiosPromise<ProductWithManufacturer> {
            return localVarFp.adminGetProduct(id, imgH, imgR, imgW, options).then((request) => request(axios, basePath));
        },
        /**
         * Get product images
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminListProductImages(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): AxiosPromise<ImageList> {
            return localVarFp.adminListProductImages(id, imgH, imgR, imgW, options).then((request) => request(axios, basePath));
        },
        /**
         * List products
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminListProducts(imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): AxiosPromise<ProductList> {
            return localVarFp.adminListProducts(imgH, imgR, imgW, options).then((request) => request(axios, basePath));
        },
        /**
         * Update product
         * @param {string} id ID
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateProduct(id: string, product: Product, options?: any): AxiosPromise<Product> {
            return localVarFp.adminUpdateProduct(id, product, options).then((request) => request(axios, basePath));
        },
        /**
         * Update product image. In case the new order matches another image, the orders are swapped. Therefore, this call will return all impacted images (1 or 2). First the image on which the request was called and optionally second the swapped image.
         * @param {string} id ID
         * @param {string} imageId Image ID
         * @param {Image} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateProductImage(id: string, imageId: string, image: Image, options?: any): AxiosPromise<ImageList> {
            return localVarFp.adminUpdateProductImage(id, imageId, image, options).then((request) => request(axios, basePath));
        },
        /**
         * Get product details
         * @param {string} id ID
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicGetProduct(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): AxiosPromise<ProductWithManufacturer> {
            return localVarFp.publicGetProduct(id, imgH, imgR, imgW, options).then((request) => request(axios, basePath));
        },
        /**
         * List products
         * @param {number} [imgH] Image height
         * @param {'FILL' | 'FIT'} [imgR] Image resize mode
         * @param {number} [imgW] Image width
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicListProducts(imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any): AxiosPromise<ProductList> {
            return localVarFp.publicListProducts(imgH, imgR, imgW, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * Add product
     * @param {Product} product 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public adminAddProduct(product: Product, options?: any) {
        return ProductsApiFp(this.configuration).adminAddProduct(product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add product images
     * @param {string} id ID
     * @param {number} [imgH] Image height
     * @param {'FILL' | 'FIT'} [imgR] Image resize mode
     * @param {number} [imgW] Image width
     * @param {Array<any>} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public adminAddProductImages(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, file?: Array<any>, options?: any) {
        return ProductsApiFp(this.configuration).adminAddProductImages(id, imgH, imgR, imgW, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete product
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public adminDeleteProduct(id: string, options?: any) {
        return ProductsApiFp(this.configuration).adminDeleteProduct(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete product image
     * @param {string} id ID
     * @param {string} imageId Image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public adminDeleteProductImage(id: string, imageId: string, options?: any) {
        return ProductsApiFp(this.configuration).adminDeleteProductImage(id, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get product details
     * @param {string} id ID
     * @param {number} [imgH] Image height
     * @param {'FILL' | 'FIT'} [imgR] Image resize mode
     * @param {number} [imgW] Image width
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public adminGetProduct(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any) {
        return ProductsApiFp(this.configuration).adminGetProduct(id, imgH, imgR, imgW, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get product images
     * @param {string} id ID
     * @param {number} [imgH] Image height
     * @param {'FILL' | 'FIT'} [imgR] Image resize mode
     * @param {number} [imgW] Image width
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public adminListProductImages(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any) {
        return ProductsApiFp(this.configuration).adminListProductImages(id, imgH, imgR, imgW, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List products
     * @param {number} [imgH] Image height
     * @param {'FILL' | 'FIT'} [imgR] Image resize mode
     * @param {number} [imgW] Image width
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public adminListProducts(imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any) {
        return ProductsApiFp(this.configuration).adminListProducts(imgH, imgR, imgW, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update product
     * @param {string} id ID
     * @param {Product} product 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public adminUpdateProduct(id: string, product: Product, options?: any) {
        return ProductsApiFp(this.configuration).adminUpdateProduct(id, product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update product image. In case the new order matches another image, the orders are swapped. Therefore, this call will return all impacted images (1 or 2). First the image on which the request was called and optionally second the swapped image.
     * @param {string} id ID
     * @param {string} imageId Image ID
     * @param {Image} image 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public adminUpdateProductImage(id: string, imageId: string, image: Image, options?: any) {
        return ProductsApiFp(this.configuration).adminUpdateProductImage(id, imageId, image, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get product details
     * @param {string} id ID
     * @param {number} [imgH] Image height
     * @param {'FILL' | 'FIT'} [imgR] Image resize mode
     * @param {number} [imgW] Image width
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public publicGetProduct(id: string, imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any) {
        return ProductsApiFp(this.configuration).publicGetProduct(id, imgH, imgR, imgW, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List products
     * @param {number} [imgH] Image height
     * @param {'FILL' | 'FIT'} [imgR] Image resize mode
     * @param {number} [imgW] Image width
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public publicListProducts(imgH?: number, imgR?: 'FILL' | 'FIT', imgW?: number, options?: any) {
        return ProductsApiFp(this.configuration).publicListProducts(imgH, imgR, imgW, options).then((request) => request(this.axios, this.basePath));
    }
}


