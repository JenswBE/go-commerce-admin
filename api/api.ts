/* tslint:disable */
/* eslint-disable */
/**
 * GoCommerce
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof Category
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'description'?: string;
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof Category
     */
    'parent_id'?: string;
    /**
     * Should be sorted ascending by this column
     * @type {number}
     * @memberof Category
     */
    'order': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Category
     */
    'product_ids'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Category
     */
    'image_urls'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CategoryAllOf
 */
export interface CategoryAllOf {
    /**
     * 
     * @type {string}
     * @memberof CategoryAllOf
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryAllOf
     */
    'description'?: string;
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof CategoryAllOf
     */
    'parent_id'?: string;
    /**
     * Should be sorted ascending by this column
     * @type {number}
     * @memberof CategoryAllOf
     */
    'order': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CategoryAllOf
     */
    'product_ids'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CategoryAllOf
     */
    'image_urls'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CategoryList
 */
export interface CategoryList {
    /**
     * 
     * @type {Array<Category>}
     * @memberof CategoryList
     */
    'categories': Array<Category>;
}
/**
 * 
 * @export
 * @interface Config
 */
export interface Config {
    /**
     * 
     * @type {ConfigFeatures}
     * @memberof Config
     */
    'features': ConfigFeatures;
}
/**
 * 
 * @export
 * @interface ConfigFeatures
 */
export interface ConfigFeatures {
    /**
     * 
     * @type {ConfigFeaturesCategories}
     * @memberof ConfigFeatures
     */
    'categories': ConfigFeaturesCategories;
    /**
     * 
     * @type {ConfigFeaturesManufacturers}
     * @memberof ConfigFeatures
     */
    'manufacturers': ConfigFeaturesManufacturers;
    /**
     * 
     * @type {ConfigFeaturesProducts}
     * @memberof ConfigFeatures
     */
    'products': ConfigFeaturesProducts;
    /**
     * 
     * @type {ConfigFeaturesContent}
     * @memberof ConfigFeatures
     */
    'content': ConfigFeaturesContent;
    /**
     * 
     * @type {ConfigFeaturesEvents}
     * @memberof ConfigFeatures
     */
    'events': ConfigFeaturesEvents;
}
/**
 * 
 * @export
 * @interface ConfigFeaturesCategories
 */
export interface ConfigFeaturesCategories {
    /**
     * 
     * @type {boolean}
     * @memberof ConfigFeaturesCategories
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface ConfigFeaturesContent
 */
export interface ConfigFeaturesContent {
    /**
     * 
     * @type {boolean}
     * @memberof ConfigFeaturesContent
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface ConfigFeaturesEvents
 */
export interface ConfigFeaturesEvents {
    /**
     * 
     * @type {boolean}
     * @memberof ConfigFeaturesEvents
     */
    'enabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigFeaturesEvents
     */
    'whole_days_only': boolean;
}
/**
 * 
 * @export
 * @interface ConfigFeaturesManufacturers
 */
export interface ConfigFeaturesManufacturers {
    /**
     * 
     * @type {boolean}
     * @memberof ConfigFeaturesManufacturers
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface ConfigFeaturesProducts
 */
export interface ConfigFeaturesProducts {
    /**
     * 
     * @type {boolean}
     * @memberof ConfigFeaturesProducts
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface Content
 */
export interface Content {
    /**
     * 
     * @type {string}
     * @memberof Content
     */
    'name': string;
    /**
     * 
     * @type {ContentType}
     * @memberof Content
     */
    'content_type': ContentType;
    /**
     * 
     * @type {string}
     * @memberof Content
     */
    'body': string;
}
/**
 * 
 * @export
 * @interface ContentList
 */
export interface ContentList {
    /**
     * 
     * @type {Array<Content>}
     * @memberof ContentList
     */
    'content': Array<Content>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ContentType {
    Simple = 'SIMPLE',
    Html = 'HTML'
}

/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof Event
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'description'?: string;
    /**
     * Type of event. Types should be defined in GoCommerce config file.
     * @type {string}
     * @memberof Event
     */
    'event_type': string;
    /**
     * Start of the event. In case \"whole_day\" is true, only the date part is considered.
     * @type {string}
     * @memberof Event
     */
    'start': string;
    /**
     * End of the event, could be same as start. In case \"whole_day\" is true, only the date part is considered.
     * @type {string}
     * @memberof Event
     */
    'end': string;
    /**
     * 
     * @type {boolean}
     * @memberof Event
     */
    'whole_day'?: boolean;
}
/**
 * 
 * @export
 * @interface EventAllOf
 */
export interface EventAllOf {
    /**
     * 
     * @type {string}
     * @memberof EventAllOf
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventAllOf
     */
    'description'?: string;
    /**
     * Type of event. Types should be defined in GoCommerce config file.
     * @type {string}
     * @memberof EventAllOf
     */
    'event_type'?: string;
    /**
     * Start of the event. In case \"whole_day\" is true, only the date part is considered.
     * @type {string}
     * @memberof EventAllOf
     */
    'start'?: string;
    /**
     * End of the event, could be same as start. In case \"whole_day\" is true, only the date part is considered.
     * @type {string}
     * @memberof EventAllOf
     */
    'end'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EventAllOf
     */
    'whole_day'?: boolean;
}
/**
 * 
 * @export
 * @interface EventList
 */
export interface EventList {
    /**
     * 
     * @type {Array<Event>}
     * @memberof EventList
     */
    'events': Array<Event>;
}
/**
 * 
 * @export
 * @interface GocomError
 */
export interface GocomError {
    /**
     * HTTP status code
     * @type {number}
     * @memberof GocomError
     */
    'status'?: number;
    /**
     * 
     * @type {GocomErrorCode}
     * @memberof GocomError
     */
    'code': GocomErrorCode;
    /**
     * Human-readable description of the error
     * @type {string}
     * @memberof GocomError
     */
    'message': string;
    /**
     * Object to which this error is related
     * @type {string}
     * @memberof GocomError
     */
    'instance'?: string;
}
/**
 * - CATEGORY_NAME_EMPTY: Category name is required and cannot be empty - CATEGORY_ORDER_NEGATIVE: Category order should be a positive integer - CATEGORY_PARENT_ID_INVALID: Parent ID of the category is invalid - CONTENT_NAME_EMPTY: Content name is required and cannot be empty - CONTENT_TYPE_INVALID: Content type is empty or has an invalid value - EVENT_END_BEFORE_START: The end date of the event should be equal to or after the start date - IMAGE_ORDER_NEGATIVE: Image order should be a positive integer - INVALID_AUTH_TOKEN: Provided authentication token is invalid - INVALID_ID: Provided short ID or UUID is invalid - MISSING_ADMIN_ROLE: Required role \"admin\" is missing on provided authentication token - PARAMETER_MISSING: A required URL parameter is missing - PRODUCT_CATEGORY_IDS_INVALID: Category ID\'s of product are invalid - PRODUCT_MANUFACTURER_ID_INVALID: Manufacturer ID of the product is invalid - PRODUCT_NAME_EMPTY: Product name is required and cannot be empty - PRODUCT_PRICE_NEGATIVE: Product price should be a positive integer - SINGLE_IMAGE_IN_FORM: Exactly one image is expected in multipart form, but none or multiple are provided - UNKNOWN_CATEGORY: The category does not exist - UNKNOWN_CONTENT: The content does not exist - UNKNOWN_ERROR: An unknown error occurred - UNKNOWN_EVENT: The event does not exist - UNKNOWN_IMAGE: The image does not exist - UNKNOWN_MANUFACTURER: The manufacturer does not exist - UNKNOWN_PRODUCT: The product does not exist 
 * @export
 * @enum {string}
 */

export enum GocomErrorCode {
    CategoryNameEmpty = 'CATEGORY_NAME_EMPTY',
    CategoryOrderNegative = 'CATEGORY_ORDER_NEGATIVE',
    CategoryParentIdInvalid = 'CATEGORY_PARENT_ID_INVALID',
    ContentNameEmpty = 'CONTENT_NAME_EMPTY',
    ContentTypeInvalid = 'CONTENT_TYPE_INVALID',
    EventEndBeforeStart = 'EVENT_END_BEFORE_START',
    ImageOrderNegative = 'IMAGE_ORDER_NEGATIVE',
    InvalidAuthToken = 'INVALID_AUTH_TOKEN',
    InvalidId = 'INVALID_ID',
    MissingAdminRole = 'MISSING_ADMIN_ROLE',
    ParameterMissing = 'PARAMETER_MISSING',
    ProductCategoryIdsInvalid = 'PRODUCT_CATEGORY_IDS_INVALID',
    ProductManufacturerIdInvalid = 'PRODUCT_MANUFACTURER_ID_INVALID',
    ProductNameEmpty = 'PRODUCT_NAME_EMPTY',
    ProductPriceNegative = 'PRODUCT_PRICE_NEGATIVE',
    SingleImageInForm = 'SINGLE_IMAGE_IN_FORM',
    UnknownCategory = 'UNKNOWN_CATEGORY',
    UnknownContent = 'UNKNOWN_CONTENT',
    UnknownError = 'UNKNOWN_ERROR',
    UnknownEvent = 'UNKNOWN_EVENT',
    UnknownImage = 'UNKNOWN_IMAGE',
    UnknownManufacturer = 'UNKNOWN_MANUFACTURER',
    UnknownProduct = 'UNKNOWN_PRODUCT'
}

/**
 * 
 * @export
 * @interface Header
 */
export interface Header {
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof Header
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface HeaderTimestamped
 */
export interface HeaderTimestamped {
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof HeaderTimestamped
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof HeaderTimestamped
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof HeaderTimestamped
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface HeaderTimestampedAllOf
 */
export interface HeaderTimestampedAllOf {
    /**
     * 
     * @type {string}
     * @memberof HeaderTimestampedAllOf
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof HeaderTimestampedAllOf
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'id': string;
    /**
     * Extension of the image
     * @type {string}
     * @memberof Image
     */
    'ext': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Image
     */
    'urls': { [key: string]: string; };
    /**
     * Should be sorted ascending by this column
     * @type {number}
     * @memberof Image
     */
    'order': number;
}
/**
 * 
 * @export
 * @interface ImageList
 */
export interface ImageList {
    /**
     * 
     * @type {Array<Image>}
     * @memberof ImageList
     */
    'images': Array<Image>;
}
/**
 * 
 * @export
 * @interface Manufacturer
 */
export interface Manufacturer {
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof Manufacturer
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Manufacturer
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Manufacturer
     */
    'website_url'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Manufacturer
     */
    'image_urls'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ManufacturerAllOf
 */
export interface ManufacturerAllOf {
    /**
     * 
     * @type {string}
     * @memberof ManufacturerAllOf
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManufacturerAllOf
     */
    'website_url'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ManufacturerAllOf
     */
    'image_urls'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ManufacturerList
 */
export interface ManufacturerList {
    /**
     * 
     * @type {Array<Manufacturer>}
     * @memberof ManufacturerList
     */
    'manufacturers': Array<Manufacturer>;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof Product
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'description_short'?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'description_long'?: string;
    /**
     * Price in cents
     * @type {number}
     * @memberof Product
     */
    'price': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Product
     */
    'category_ids'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'manufacturer_id'?: string;
    /**
     * 
     * @type {ProductStatus}
     * @memberof Product
     */
    'status'?: ProductStatus;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'stock_count'?: number;
    /**
     * 
     * @type {Array<{ [key: string]: string; }>}
     * @memberof Product
     */
    'image_urls'?: Array<{ [key: string]: string; }>;
}
/**
 * 
 * @export
 * @interface ProductAllOf
 */
export interface ProductAllOf {
    /**
     * 
     * @type {string}
     * @memberof ProductAllOf
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProductAllOf
     */
    'description_short'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductAllOf
     */
    'description_long'?: string;
    /**
     * Price in cents
     * @type {number}
     * @memberof ProductAllOf
     */
    'price': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductAllOf
     */
    'category_ids'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ProductAllOf
     */
    'manufacturer_id'?: string;
    /**
     * 
     * @type {ProductStatus}
     * @memberof ProductAllOf
     */
    'status'?: ProductStatus;
    /**
     * 
     * @type {number}
     * @memberof ProductAllOf
     */
    'stock_count'?: number;
    /**
     * 
     * @type {Array<{ [key: string]: string; }>}
     * @memberof ProductAllOf
     */
    'image_urls'?: Array<{ [key: string]: string; }>;
}
/**
 * 
 * @export
 * @interface ProductList
 */
export interface ProductList {
    /**
     * 
     * @type {Array<Product>}
     * @memberof ProductList
     */
    'products': Array<Product>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ProductStatus {
    Available = 'AVAILABLE',
    Archived = 'ARCHIVED'
}

/**
 * 
 * @export
 * @interface ResolvedProduct
 */
export interface ResolvedProduct {
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof ResolvedProduct
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResolvedProduct
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResolvedProduct
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResolvedProduct
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResolvedProduct
     */
    'description_short'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResolvedProduct
     */
    'description_long'?: string;
    /**
     * Price in cents
     * @type {number}
     * @memberof ResolvedProduct
     */
    'price': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResolvedProduct
     */
    'category_ids'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ResolvedProduct
     */
    'manufacturer_id'?: string;
    /**
     * 
     * @type {ProductStatus}
     * @memberof ResolvedProduct
     */
    'status'?: ProductStatus;
    /**
     * 
     * @type {number}
     * @memberof ResolvedProduct
     */
    'stock_count'?: number;
    /**
     * 
     * @type {Array<{ [key: string]: string; }>}
     * @memberof ResolvedProduct
     */
    'image_urls'?: Array<{ [key: string]: string; }>;
    /**
     * 
     * @type {Manufacturer}
     * @memberof ResolvedProduct
     */
    'manufacturer'?: Manufacturer;
    /**
     * 
     * @type {Array<Category>}
     * @memberof ResolvedProduct
     */
    'categories'?: Array<Category>;
}
/**
 * 
 * @export
 * @interface ResolvedProductAllOf
 */
export interface ResolvedProductAllOf {
    /**
     * 
     * @type {Manufacturer}
     * @memberof ResolvedProductAllOf
     */
    'manufacturer'?: Manufacturer;
    /**
     * 
     * @type {Array<Category>}
     * @memberof ResolvedProductAllOf
     */
    'categories'?: Array<Category>;
}

/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add category
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCategory: async (category: Category, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'category' is not null or undefined
            assertParamExists('addCategory', 'category', category)
            const localVarPath = `/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(category, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete category
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCategory', 'id', id)
            const localVarPath = `/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete image
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategoryImage: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCategoryImage', 'id', id)
            const localVarPath = `/categories/{id}/image/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get category details
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory: async (id: string, img?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCategory', 'id', id)
            const localVarPath = `/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (img) {
                localVarQueryParameter['img'] = img.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List categories
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategories: async (img?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (img) {
                localVarQueryParameter['img'] = img.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update category
         * @param {string} id ID
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory: async (id: string, category: Category, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCategory', 'id', id)
            // verify required parameter 'category' is not null or undefined
            assertParamExists('updateCategory', 'category', category)
            const localVarPath = `/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(category, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upsert image
         * @param {string} id ID
         * @param {any} file 
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertCategoryImage: async (id: string, file: any, img?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('upsertCategoryImage', 'id', id)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('upsertCategoryImage', 'file', file)
            const localVarPath = `/categories/{id}/image/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (img) {
                localVarQueryParameter['img'] = img.join(COLLECTION_FORMATS.csv);
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Add category
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCategory(category: Category, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCategory(category, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete category
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCategory(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategory(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete image
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCategoryImage(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategoryImage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get category details
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategory(id: string, img?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategory(id, img, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List categories
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCategories(img?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCategories(img, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update category
         * @param {string} id ID
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCategory(id: string, category: Category, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategory(id, category, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upsert image
         * @param {string} id ID
         * @param {any} file 
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertCategoryImage(id: string, file: any, img?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upsertCategoryImage(id, file, img, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoriesApiFp(configuration)
    return {
        /**
         * Add category
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCategory(category: Category, options?: any): AxiosPromise<Category> {
            return localVarFp.addCategory(category, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete category
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete image
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategoryImage(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCategoryImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get category details
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory(id: string, img?: Array<string>, options?: any): AxiosPromise<Category> {
            return localVarFp.getCategory(id, img, options).then((request) => request(axios, basePath));
        },
        /**
         * List categories
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategories(img?: Array<string>, options?: any): AxiosPromise<CategoryList> {
            return localVarFp.listCategories(img, options).then((request) => request(axios, basePath));
        },
        /**
         * Update category
         * @param {string} id ID
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(id: string, category: Category, options?: any): AxiosPromise<Category> {
            return localVarFp.updateCategory(id, category, options).then((request) => request(axios, basePath));
        },
        /**
         * Upsert image
         * @param {string} id ID
         * @param {any} file 
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertCategoryImage(id: string, file: any, img?: Array<string>, options?: any): AxiosPromise<Image> {
            return localVarFp.upsertCategoryImage(id, file, img, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
    /**
     * Add category
     * @param {Category} category 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public addCategory(category: Category, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).addCategory(category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete category
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public deleteCategory(id: string, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).deleteCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete image
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public deleteCategoryImage(id: string, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).deleteCategoryImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get category details
     * @param {string} id ID
     * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public getCategory(id: string, img?: Array<string>, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).getCategory(id, img, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List categories
     * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public listCategories(img?: Array<string>, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).listCategories(img, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update category
     * @param {string} id ID
     * @param {Category} category 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public updateCategory(id: string, category: Category, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).updateCategory(id, category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upsert image
     * @param {string} id ID
     * @param {any} file 
     * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public upsertCategoryImage(id: string, file: any, img?: Array<string>, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).upsertCategoryImage(id, file, img, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConfigApi - axios parameter creator
 * @export
 */
export const ConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/config/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigApi - functional programming interface
 * @export
 */
export const ConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * Get configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Config>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConfigApi - factory interface
 * @export
 */
export const ConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigApiFp(configuration)
    return {
        /**
         * Get configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(options?: any): AxiosPromise<Config> {
            return localVarFp.getConfig(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConfigApi - object-oriented interface
 * @export
 * @class ConfigApi
 * @extends {BaseAPI}
 */
export class ConfigApi extends BaseAPI {
    /**
     * Get configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApi
     */
    public getConfig(options?: AxiosRequestConfig) {
        return ConfigApiFp(this.configuration).getConfig(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContentApi - axios parameter creator
 * @export
 */
export const ContentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get content
         * @param {string} contentName Content name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContent: async (contentName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentName' is not null or undefined
            assertParamExists('getContent', 'contentName', contentName)
            const localVarPath = `/content/{content_name}/`
                .replace(`{${"content_name"}}`, encodeURIComponent(String(contentName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContent: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/content/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update content
         * @param {string} contentName Content name
         * @param {Content} content 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContent: async (contentName: string, content: Content, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentName' is not null or undefined
            assertParamExists('updateContent', 'contentName', contentName)
            // verify required parameter 'content' is not null or undefined
            assertParamExists('updateContent', 'content', content)
            const localVarPath = `/content/{content_name}/`
                .replace(`{${"content_name"}}`, encodeURIComponent(String(contentName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(content, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentApi - functional programming interface
 * @export
 */
export const ContentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentApiAxiosParamCreator(configuration)
    return {
        /**
         * Get content
         * @param {string} contentName Content name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContent(contentName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Content>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContent(contentName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContent(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContentList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContent(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update content
         * @param {string} contentName Content name
         * @param {Content} content 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContent(contentName: string, content: Content, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Content>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContent(contentName, content, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContentApi - factory interface
 * @export
 */
export const ContentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentApiFp(configuration)
    return {
        /**
         * Get content
         * @param {string} contentName Content name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContent(contentName: string, options?: any): AxiosPromise<Content> {
            return localVarFp.getContent(contentName, options).then((request) => request(axios, basePath));
        },
        /**
         * List content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContent(options?: any): AxiosPromise<ContentList> {
            return localVarFp.listContent(options).then((request) => request(axios, basePath));
        },
        /**
         * Update content
         * @param {string} contentName Content name
         * @param {Content} content 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContent(contentName: string, content: Content, options?: any): AxiosPromise<Content> {
            return localVarFp.updateContent(contentName, content, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentApi - object-oriented interface
 * @export
 * @class ContentApi
 * @extends {BaseAPI}
 */
export class ContentApi extends BaseAPI {
    /**
     * Get content
     * @param {string} contentName Content name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getContent(contentName: string, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).getContent(contentName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public listContent(options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).listContent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update content
     * @param {string} contentName Content name
     * @param {Content} content 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public updateContent(contentName: string, content: Content, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).updateContent(contentName, content, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add event
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEvent: async (event: Event, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'event' is not null or undefined
            assertParamExists('addEvent', 'event', event)
            const localVarPath = `/events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(event, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete event
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteEvent', 'id', id)
            const localVarPath = `/events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get event details
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEvent', 'id', id)
            const localVarPath = `/events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List events
         * @param {boolean} [includePastEvents] Include events which are already done (end time in the past).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents: async (includePastEvents?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includePastEvents !== undefined) {
                localVarQueryParameter['include_past_events'] = includePastEvents;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update event
         * @param {string} id ID
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent: async (id: string, event: Event, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateEvent', 'id', id)
            // verify required parameter 'event' is not null or undefined
            assertParamExists('updateEvent', 'event', event)
            const localVarPath = `/events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(event, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add event
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addEvent(event: Event, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addEvent(event, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete event
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEvent(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEvent(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get event details
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvent(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvent(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List events
         * @param {boolean} [includePastEvents] Include events which are already done (end time in the past).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEvents(includePastEvents?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEvents(includePastEvents, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update event
         * @param {string} id ID
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEvent(id: string, event: Event, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvent(id, event, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * Add event
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEvent(event: Event, options?: any): AxiosPromise<Event> {
            return localVarFp.addEvent(event, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete event
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEvent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get event details
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(id: string, options?: any): AxiosPromise<Event> {
            return localVarFp.getEvent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List events
         * @param {boolean} [includePastEvents] Include events which are already done (end time in the past).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents(includePastEvents?: boolean, options?: any): AxiosPromise<EventList> {
            return localVarFp.listEvents(includePastEvents, options).then((request) => request(axios, basePath));
        },
        /**
         * Update event
         * @param {string} id ID
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent(id: string, event: Event, options?: any): AxiosPromise<Event> {
            return localVarFp.updateEvent(id, event, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * Add event
     * @param {Event} event 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public addEvent(event: Event, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).addEvent(event, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete event
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public deleteEvent(id: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).deleteEvent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get event details
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEvent(id: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEvent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List events
     * @param {boolean} [includePastEvents] Include events which are already done (end time in the past).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public listEvents(includePastEvents?: boolean, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).listEvents(includePastEvents, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update event
     * @param {string} id ID
     * @param {Event} event 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateEvent(id: string, event: Event, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).updateEvent(id, event, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ManufacturersApi - axios parameter creator
 * @export
 */
export const ManufacturersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add manufacturer
         * @param {Manufacturer} manufacturer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addManufacturer: async (manufacturer: Manufacturer, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'manufacturer' is not null or undefined
            assertParamExists('addManufacturer', 'manufacturer', manufacturer)
            const localVarPath = `/manufacturers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manufacturer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete manufacturer
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteManufacturer: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteManufacturer', 'id', id)
            const localVarPath = `/manufacturers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete image
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteManufacturerImage: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteManufacturerImage', 'id', id)
            const localVarPath = `/manufacturers/{id}/image/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get manufacturer details
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManufacturer: async (id: string, img?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getManufacturer', 'id', id)
            const localVarPath = `/manufacturers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (img) {
                localVarQueryParameter['img'] = img.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List manufacturers
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listManufacturers: async (img?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/manufacturers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (img) {
                localVarQueryParameter['img'] = img.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update manufacturer
         * @param {string} id ID
         * @param {Manufacturer} manufacturer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateManufacturer: async (id: string, manufacturer: Manufacturer, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateManufacturer', 'id', id)
            // verify required parameter 'manufacturer' is not null or undefined
            assertParamExists('updateManufacturer', 'manufacturer', manufacturer)
            const localVarPath = `/manufacturers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manufacturer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upsert image
         * @param {string} id ID
         * @param {any} file 
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertManufacturerImage: async (id: string, file: any, img?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('upsertManufacturerImage', 'id', id)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('upsertManufacturerImage', 'file', file)
            const localVarPath = `/manufacturers/{id}/image/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (img) {
                localVarQueryParameter['img'] = img.join(COLLECTION_FORMATS.csv);
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManufacturersApi - functional programming interface
 * @export
 */
export const ManufacturersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManufacturersApiAxiosParamCreator(configuration)
    return {
        /**
         * Add manufacturer
         * @param {Manufacturer} manufacturer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addManufacturer(manufacturer: Manufacturer, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addManufacturer(manufacturer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete manufacturer
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteManufacturer(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteManufacturer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete image
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteManufacturerImage(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteManufacturerImage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get manufacturer details
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getManufacturer(id: string, img?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManufacturer(id, img, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List manufacturers
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listManufacturers(img?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManufacturerList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listManufacturers(img, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update manufacturer
         * @param {string} id ID
         * @param {Manufacturer} manufacturer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateManufacturer(id: string, manufacturer: Manufacturer, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateManufacturer(id, manufacturer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upsert image
         * @param {string} id ID
         * @param {any} file 
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertManufacturerImage(id: string, file: any, img?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upsertManufacturerImage(id, file, img, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ManufacturersApi - factory interface
 * @export
 */
export const ManufacturersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManufacturersApiFp(configuration)
    return {
        /**
         * Add manufacturer
         * @param {Manufacturer} manufacturer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addManufacturer(manufacturer: Manufacturer, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.addManufacturer(manufacturer, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete manufacturer
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteManufacturer(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteManufacturer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete image
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteManufacturerImage(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteManufacturerImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get manufacturer details
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManufacturer(id: string, img?: Array<string>, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.getManufacturer(id, img, options).then((request) => request(axios, basePath));
        },
        /**
         * List manufacturers
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listManufacturers(img?: Array<string>, options?: any): AxiosPromise<ManufacturerList> {
            return localVarFp.listManufacturers(img, options).then((request) => request(axios, basePath));
        },
        /**
         * Update manufacturer
         * @param {string} id ID
         * @param {Manufacturer} manufacturer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateManufacturer(id: string, manufacturer: Manufacturer, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.updateManufacturer(id, manufacturer, options).then((request) => request(axios, basePath));
        },
        /**
         * Upsert image
         * @param {string} id ID
         * @param {any} file 
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertManufacturerImage(id: string, file: any, img?: Array<string>, options?: any): AxiosPromise<Image> {
            return localVarFp.upsertManufacturerImage(id, file, img, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManufacturersApi - object-oriented interface
 * @export
 * @class ManufacturersApi
 * @extends {BaseAPI}
 */
export class ManufacturersApi extends BaseAPI {
    /**
     * Add manufacturer
     * @param {Manufacturer} manufacturer 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public addManufacturer(manufacturer: Manufacturer, options?: AxiosRequestConfig) {
        return ManufacturersApiFp(this.configuration).addManufacturer(manufacturer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete manufacturer
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public deleteManufacturer(id: string, options?: AxiosRequestConfig) {
        return ManufacturersApiFp(this.configuration).deleteManufacturer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete image
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public deleteManufacturerImage(id: string, options?: AxiosRequestConfig) {
        return ManufacturersApiFp(this.configuration).deleteManufacturerImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get manufacturer details
     * @param {string} id ID
     * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public getManufacturer(id: string, img?: Array<string>, options?: AxiosRequestConfig) {
        return ManufacturersApiFp(this.configuration).getManufacturer(id, img, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List manufacturers
     * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public listManufacturers(img?: Array<string>, options?: AxiosRequestConfig) {
        return ManufacturersApiFp(this.configuration).listManufacturers(img, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update manufacturer
     * @param {string} id ID
     * @param {Manufacturer} manufacturer 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public updateManufacturer(id: string, manufacturer: Manufacturer, options?: AxiosRequestConfig) {
        return ManufacturersApiFp(this.configuration).updateManufacturer(id, manufacturer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upsert image
     * @param {string} id ID
     * @param {any} file 
     * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public upsertManufacturerImage(id: string, file: any, img?: Array<string>, options?: AxiosRequestConfig) {
        return ManufacturersApiFp(this.configuration).upsertManufacturerImage(id, file, img, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add product
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProduct: async (product: Product, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'product' is not null or undefined
            assertParamExists('addProduct', 'product', product)
            const localVarPath = `/products/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(product, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add product images
         * @param {string} id ID
         * @param {Array<any>} file 
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProductImages: async (id: string, file: Array<any>, img?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addProductImages', 'id', id)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('addProductImages', 'file', file)
            const localVarPath = `/products/{id}/images/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (img) {
                localVarQueryParameter['img'] = img.join(COLLECTION_FORMATS.csv);
            }

            if (file) {
                file.forEach((element) => {
                    localVarFormParams.append('file', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete product
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProduct', 'id', id)
            const localVarPath = `/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete product image
         * @param {string} id ID
         * @param {string} imageId Image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductImage: async (id: string, imageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProductImage', 'id', id)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('deleteProductImage', 'imageId', imageId)
            const localVarPath = `/products/{id}/images/{image_id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get product details
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {boolean} [resolve] The returned object should include related objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct: async (id: string, img?: Array<string>, resolve?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProduct', 'id', id)
            const localVarPath = `/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (img) {
                localVarQueryParameter['img'] = img.join(COLLECTION_FORMATS.csv);
            }

            if (resolve !== undefined) {
                localVarQueryParameter['resolve'] = resolve;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get product images
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductImages: async (id: string, img?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listProductImages', 'id', id)
            const localVarPath = `/products/{id}/images/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (img) {
                localVarQueryParameter['img'] = img.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List products
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts: async (img?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (img) {
                localVarQueryParameter['img'] = img.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update product
         * @param {string} id ID
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct: async (id: string, product: Product, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProduct', 'id', id)
            // verify required parameter 'product' is not null or undefined
            assertParamExists('updateProduct', 'product', product)
            const localVarPath = `/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(product, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update product image. In case the new order matches another image, the orders are swapped. Therefore, this call will return all impacted images (1 or 2). First the image on which the request was called and optionally second the swapped image.
         * @param {string} id ID
         * @param {string} imageId Image ID
         * @param {Image} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductImage: async (id: string, imageId: string, image: Image, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProductImage', 'id', id)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('updateProductImage', 'imageId', imageId)
            // verify required parameter 'image' is not null or undefined
            assertParamExists('updateProductImage', 'image', image)
            const localVarPath = `/products/{id}/images/{image_id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(image, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add product
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addProduct(product: Product, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addProduct(product, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add product images
         * @param {string} id ID
         * @param {Array<any>} file 
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addProductImages(id: string, file: Array<any>, img?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addProductImages(id, file, img, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete product
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProduct(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProduct(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete product image
         * @param {string} id ID
         * @param {string} imageId Image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductImage(id: string, imageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProductImage(id, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get product details
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {boolean} [resolve] The returned object should include related objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProduct(id: string, img?: Array<string>, resolve?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResolvedProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProduct(id, img, resolve, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get product images
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProductImages(id: string, img?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProductImages(id, img, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List products
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProducts(img?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProducts(img, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update product
         * @param {string} id ID
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProduct(id: string, product: Product, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProduct(id, product, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update product image. In case the new order matches another image, the orders are swapped. Therefore, this call will return all impacted images (1 or 2). First the image on which the request was called and optionally second the swapped image.
         * @param {string} id ID
         * @param {string} imageId Image ID
         * @param {Image} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProductImage(id: string, imageId: string, image: Image, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProductImage(id, imageId, image, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * Add product
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProduct(product: Product, options?: any): AxiosPromise<Product> {
            return localVarFp.addProduct(product, options).then((request) => request(axios, basePath));
        },
        /**
         * Add product images
         * @param {string} id ID
         * @param {Array<any>} file 
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProductImages(id: string, file: Array<any>, img?: Array<string>, options?: any): AxiosPromise<ImageList> {
            return localVarFp.addProductImages(id, file, img, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete product
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete product image
         * @param {string} id ID
         * @param {string} imageId Image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductImage(id: string, imageId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProductImage(id, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get product details
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {boolean} [resolve] The returned object should include related objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(id: string, img?: Array<string>, resolve?: boolean, options?: any): AxiosPromise<ResolvedProduct> {
            return localVarFp.getProduct(id, img, resolve, options).then((request) => request(axios, basePath));
        },
        /**
         * Get product images
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductImages(id: string, img?: Array<string>, options?: any): AxiosPromise<ImageList> {
            return localVarFp.listProductImages(id, img, options).then((request) => request(axios, basePath));
        },
        /**
         * List products
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts(img?: Array<string>, options?: any): AxiosPromise<ProductList> {
            return localVarFp.listProducts(img, options).then((request) => request(axios, basePath));
        },
        /**
         * Update product
         * @param {string} id ID
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(id: string, product: Product, options?: any): AxiosPromise<Product> {
            return localVarFp.updateProduct(id, product, options).then((request) => request(axios, basePath));
        },
        /**
         * Update product image. In case the new order matches another image, the orders are swapped. Therefore, this call will return all impacted images (1 or 2). First the image on which the request was called and optionally second the swapped image.
         * @param {string} id ID
         * @param {string} imageId Image ID
         * @param {Image} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductImage(id: string, imageId: string, image: Image, options?: any): AxiosPromise<ImageList> {
            return localVarFp.updateProductImage(id, imageId, image, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * Add product
     * @param {Product} product 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public addProduct(product: Product, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).addProduct(product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add product images
     * @param {string} id ID
     * @param {Array<any>} file 
     * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public addProductImages(id: string, file: Array<any>, img?: Array<string>, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).addProductImages(id, file, img, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete product
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProduct(id: string, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).deleteProduct(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete product image
     * @param {string} id ID
     * @param {string} imageId Image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProductImage(id: string, imageId: string, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).deleteProductImage(id, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get product details
     * @param {string} id ID
     * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
     * @param {boolean} [resolve] The returned object should include related objects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProduct(id: string, img?: Array<string>, resolve?: boolean, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getProduct(id, img, resolve, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get product images
     * @param {string} id ID
     * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public listProductImages(id: string, img?: Array<string>, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).listProductImages(id, img, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List products
     * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public listProducts(img?: Array<string>, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).listProducts(img, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update product
     * @param {string} id ID
     * @param {Product} product 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public updateProduct(id: string, product: Product, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).updateProduct(id, product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update product image. In case the new order matches another image, the orders are swapped. Therefore, this call will return all impacted images (1 or 2). First the image on which the request was called and optionally second the swapped image.
     * @param {string} id ID
     * @param {string} imageId Image ID
     * @param {Image} image 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public updateProductImage(id: string, imageId: string, image: Image, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).updateProductImage(id, imageId, image, options).then((request) => request(this.axios, this.basePath));
    }
}


