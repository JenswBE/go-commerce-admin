/* tslint:disable */
/* eslint-disable */
/**
 * GoCommerce
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof Category
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    description?: string;
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof Category
     */
    parent_id?: string;
    /**
     * Should be sorted ascending by this column
     * @type {number}
     * @memberof Category
     */
    order: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Category
     */
    product_ids?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Category
     */
    image_urls?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CategoryAllOf
 */
export interface CategoryAllOf {
    /**
     * 
     * @type {string}
     * @memberof CategoryAllOf
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryAllOf
     */
    description?: string;
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof CategoryAllOf
     */
    parent_id?: string;
    /**
     * Should be sorted ascending by this column
     * @type {number}
     * @memberof CategoryAllOf
     */
    order: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CategoryAllOf
     */
    product_ids?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CategoryAllOf
     */
    image_urls?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CategoryList
 */
export interface CategoryList {
    /**
     * 
     * @type {Array<Category>}
     * @memberof CategoryList
     */
    categories: Array<Category>;
}
/**
 * 
 * @export
 * @interface GocomError
 */
export interface GocomError {
    /**
     * HTTP status code
     * @type {number}
     * @memberof GocomError
     */
    status?: number;
    /**
     * 
     * @type {GocomErrorCode}
     * @memberof GocomError
     */
    code: GocomErrorCode;
    /**
     * Human-readable description of the error
     * @type {string}
     * @memberof GocomError
     */
    message: string;
    /**
     * Object to which this error is related
     * @type {string}
     * @memberof GocomError
     */
    instance?: string;
}
/**
 * - CATEGORY_NAME_EMPTY: Category name is required and cannot be empty - CATEGORY_ORDER_NEGATIVE: Category order should be a positive integer - CATEGORY_PARENT_ID_INVALID: Parent ID of the category is invalid - IMAGE_ORDER_NEGATIVE: Image order should be a positive integer - INVALID_AUTH_TOKEN: Provided authentication token is invalid - INVALID_ID: Provided short ID or UUID is invalid - MISSING_ADMIN_ROLE: Required role \"admin\" is missing on provided authentication token - PARAMETER_MISSING: A required URL parameter is missing - PRODUCT_CATEGORY_IDS_INVALID: Category ID\'s of product are invalid - PRODUCT_MANUFACTURER_ID_INVALID: Manufacturer ID of the product is invalid - PRODUCT_NAME_EMPTY: Product name is required and cannot be empty - PRODUCT_PRICE_NEGATIVE: Product price should be a positive integer - SINGLE_IMAGE_IN_FORM: Exactly one image is expected in multipart form, but none or multiple are provided - UNKNOWN_CATEGORY: The category does not exist - UNKNOWN_ERROR: An unknown error occurred - UNKNOWN_IMAGE: The image does not exist - UNKNOWN_MANUFACTURER: The manufacturer does not exist - UNKNOWN_PRODUCT: The product does not exist 
 * @export
 * @enum {string}
 */

export enum GocomErrorCode {
    CategoryNameEmpty = 'CATEGORY_NAME_EMPTY',
    CategoryOrderNegative = 'CATEGORY_ORDER_NEGATIVE',
    CategoryParentIdInvalid = 'CATEGORY_PARENT_ID_INVALID',
    ImageOrderNegative = 'IMAGE_ORDER_NEGATIVE',
    InvalidAuthToken = 'INVALID_AUTH_TOKEN',
    InvalidId = 'INVALID_ID',
    MissingAdminRole = 'MISSING_ADMIN_ROLE',
    ParameterMissing = 'PARAMETER_MISSING',
    ProductCategoryIdsInvalid = 'PRODUCT_CATEGORY_IDS_INVALID',
    ProductManufacturerIdInvalid = 'PRODUCT_MANUFACTURER_ID_INVALID',
    ProductNameEmpty = 'PRODUCT_NAME_EMPTY',
    ProductPriceNegative = 'PRODUCT_PRICE_NEGATIVE',
    SingleImageInForm = 'SINGLE_IMAGE_IN_FORM',
    UnknownCategory = 'UNKNOWN_CATEGORY',
    UnknownError = 'UNKNOWN_ERROR',
    UnknownImage = 'UNKNOWN_IMAGE',
    UnknownManufacturer = 'UNKNOWN_MANUFACTURER',
    UnknownProduct = 'UNKNOWN_PRODUCT'
}

/**
 * 
 * @export
 * @interface Header
 */
export interface Header {
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof Header
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface HeaderTimestamped
 */
export interface HeaderTimestamped {
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof HeaderTimestamped
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof HeaderTimestamped
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof HeaderTimestamped
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface HeaderTimestampedAllOf
 */
export interface HeaderTimestampedAllOf {
    /**
     * 
     * @type {string}
     * @memberof HeaderTimestampedAllOf
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof HeaderTimestampedAllOf
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    id: string;
    /**
     * Extension of the image
     * @type {string}
     * @memberof Image
     */
    ext: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Image
     */
    urls: { [key: string]: string; };
    /**
     * Should be sorted ascending by this column
     * @type {number}
     * @memberof Image
     */
    order: number;
}
/**
 * 
 * @export
 * @interface ImageList
 */
export interface ImageList {
    /**
     * 
     * @type {Array<Image>}
     * @memberof ImageList
     */
    images: Array<Image>;
}
/**
 * 
 * @export
 * @interface Manufacturer
 */
export interface Manufacturer {
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof Manufacturer
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Manufacturer
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Manufacturer
     */
    website_url?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Manufacturer
     */
    image_urls?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ManufacturerAllOf
 */
export interface ManufacturerAllOf {
    /**
     * 
     * @type {string}
     * @memberof ManufacturerAllOf
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ManufacturerAllOf
     */
    website_url?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ManufacturerAllOf
     */
    image_urls?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ManufacturerList
 */
export interface ManufacturerList {
    /**
     * 
     * @type {Array<Manufacturer>}
     * @memberof ManufacturerList
     */
    manufacturers: Array<Manufacturer>;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof Product
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    description_short?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    description_long?: string;
    /**
     * Price in cents
     * @type {number}
     * @memberof Product
     */
    price: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Product
     */
    category_ids?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    manufacturer_id?: string;
    /**
     * 
     * @type {ProductStatus}
     * @memberof Product
     */
    status?: ProductStatus;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    stock_count?: number;
    /**
     * 
     * @type {Array<{ [key: string]: string; }>}
     * @memberof Product
     */
    image_urls?: Array<{ [key: string]: string; }>;
}
/**
 * 
 * @export
 * @interface ProductAllOf
 */
export interface ProductAllOf {
    /**
     * 
     * @type {string}
     * @memberof ProductAllOf
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ProductAllOf
     */
    description_short?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductAllOf
     */
    description_long?: string;
    /**
     * Price in cents
     * @type {number}
     * @memberof ProductAllOf
     */
    price: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductAllOf
     */
    category_ids?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ProductAllOf
     */
    manufacturer_id?: string;
    /**
     * 
     * @type {ProductStatus}
     * @memberof ProductAllOf
     */
    status?: ProductStatus;
    /**
     * 
     * @type {number}
     * @memberof ProductAllOf
     */
    stock_count?: number;
    /**
     * 
     * @type {Array<{ [key: string]: string; }>}
     * @memberof ProductAllOf
     */
    image_urls?: Array<{ [key: string]: string; }>;
}
/**
 * 
 * @export
 * @interface ProductList
 */
export interface ProductList {
    /**
     * 
     * @type {Array<Product>}
     * @memberof ProductList
     */
    products: Array<Product>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ProductStatus {
    Available = 'AVAILABLE',
    Archived = 'ARCHIVED'
}

/**
 * 
 * @export
 * @interface ResolvedProduct
 */
export interface ResolvedProduct {
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof ResolvedProduct
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ResolvedProduct
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ResolvedProduct
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ResolvedProduct
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ResolvedProduct
     */
    description_short?: string;
    /**
     * 
     * @type {string}
     * @memberof ResolvedProduct
     */
    description_long?: string;
    /**
     * Price in cents
     * @type {number}
     * @memberof ResolvedProduct
     */
    price: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResolvedProduct
     */
    category_ids?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ResolvedProduct
     */
    manufacturer_id?: string;
    /**
     * 
     * @type {ProductStatus}
     * @memberof ResolvedProduct
     */
    status?: ProductStatus;
    /**
     * 
     * @type {number}
     * @memberof ResolvedProduct
     */
    stock_count?: number;
    /**
     * 
     * @type {Array<{ [key: string]: string; }>}
     * @memberof ResolvedProduct
     */
    image_urls?: Array<{ [key: string]: string; }>;
    /**
     * 
     * @type {Manufacturer}
     * @memberof ResolvedProduct
     */
    manufacturer?: Manufacturer;
    /**
     * 
     * @type {Array<Category>}
     * @memberof ResolvedProduct
     */
    categories?: Array<Category>;
}
/**
 * 
 * @export
 * @interface ResolvedProductAllOf
 */
export interface ResolvedProductAllOf {
    /**
     * 
     * @type {Manufacturer}
     * @memberof ResolvedProductAllOf
     */
    manufacturer?: Manufacturer;
    /**
     * 
     * @type {Array<Category>}
     * @memberof ResolvedProductAllOf
     */
    categories?: Array<Category>;
}

/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add category
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCategory: async (category: Category, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'category' is not null or undefined
            assertParamExists('addCategory', 'category', category)
            const localVarPath = `/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(category, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete category
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCategory', 'id', id)
            const localVarPath = `/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete image
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategoryImage: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCategoryImage', 'id', id)
            const localVarPath = `/categories/{id}/image/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get category details
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory: async (id: string, img?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCategory', 'id', id)
            const localVarPath = `/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (img) {
                localVarQueryParameter['img'] = img.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List categories
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategories: async (img?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (img) {
                localVarQueryParameter['img'] = img.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update category
         * @param {string} id ID
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory: async (id: string, category: Category, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCategory', 'id', id)
            // verify required parameter 'category' is not null or undefined
            assertParamExists('updateCategory', 'category', category)
            const localVarPath = `/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(category, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upsert image
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertCategoryImage: async (id: string, img?: Array<string>, file?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('upsertCategoryImage', 'id', id)
            const localVarPath = `/categories/{id}/image/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (img) {
                localVarQueryParameter['img'] = img.join(COLLECTION_FORMATS.csv);
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Add category
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCategory(category: Category, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCategory(category, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete category
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCategory(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategory(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete image
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCategoryImage(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategoryImage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get category details
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategory(id: string, img?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategory(id, img, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List categories
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCategories(img?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCategories(img, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update category
         * @param {string} id ID
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCategory(id: string, category: Category, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategory(id, category, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upsert image
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertCategoryImage(id: string, img?: Array<string>, file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upsertCategoryImage(id, img, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoriesApiFp(configuration)
    return {
        /**
         * Add category
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCategory(category: Category, options?: any): AxiosPromise<Category> {
            return localVarFp.addCategory(category, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete category
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete image
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategoryImage(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCategoryImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get category details
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory(id: string, img?: Array<string>, options?: any): AxiosPromise<Category> {
            return localVarFp.getCategory(id, img, options).then((request) => request(axios, basePath));
        },
        /**
         * List categories
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategories(img?: Array<string>, options?: any): AxiosPromise<CategoryList> {
            return localVarFp.listCategories(img, options).then((request) => request(axios, basePath));
        },
        /**
         * Update category
         * @param {string} id ID
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(id: string, category: Category, options?: any): AxiosPromise<Category> {
            return localVarFp.updateCategory(id, category, options).then((request) => request(axios, basePath));
        },
        /**
         * Upsert image
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertCategoryImage(id: string, img?: Array<string>, file?: any, options?: any): AxiosPromise<Image> {
            return localVarFp.upsertCategoryImage(id, img, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
    /**
     * Add category
     * @param {Category} category 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public addCategory(category: Category, options?: any) {
        return CategoriesApiFp(this.configuration).addCategory(category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete category
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public deleteCategory(id: string, options?: any) {
        return CategoriesApiFp(this.configuration).deleteCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete image
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public deleteCategoryImage(id: string, options?: any) {
        return CategoriesApiFp(this.configuration).deleteCategoryImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get category details
     * @param {string} id ID
     * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public getCategory(id: string, img?: Array<string>, options?: any) {
        return CategoriesApiFp(this.configuration).getCategory(id, img, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List categories
     * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public listCategories(img?: Array<string>, options?: any) {
        return CategoriesApiFp(this.configuration).listCategories(img, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update category
     * @param {string} id ID
     * @param {Category} category 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public updateCategory(id: string, category: Category, options?: any) {
        return CategoriesApiFp(this.configuration).updateCategory(id, category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upsert image
     * @param {string} id ID
     * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public upsertCategoryImage(id: string, img?: Array<string>, file?: any, options?: any) {
        return CategoriesApiFp(this.configuration).upsertCategoryImage(id, img, file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ManufacturersApi - axios parameter creator
 * @export
 */
export const ManufacturersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add manufacturer
         * @param {Manufacturer} manufacturer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addManufacturer: async (manufacturer: Manufacturer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'manufacturer' is not null or undefined
            assertParamExists('addManufacturer', 'manufacturer', manufacturer)
            const localVarPath = `/manufacturers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manufacturer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete manufacturer
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteManufacturer: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteManufacturer', 'id', id)
            const localVarPath = `/manufacturers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete image
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteManufacturerImage: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteManufacturerImage', 'id', id)
            const localVarPath = `/manufacturers/{id}/image/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get manufacturer details
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManufacturer: async (id: string, img?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getManufacturer', 'id', id)
            const localVarPath = `/manufacturers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (img) {
                localVarQueryParameter['img'] = img.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List manufacturers
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listManufacturers: async (img?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/manufacturers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (img) {
                localVarQueryParameter['img'] = img.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update manufacturer
         * @param {string} id ID
         * @param {Manufacturer} manufacturer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateManufacturer: async (id: string, manufacturer: Manufacturer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateManufacturer', 'id', id)
            // verify required parameter 'manufacturer' is not null or undefined
            assertParamExists('updateManufacturer', 'manufacturer', manufacturer)
            const localVarPath = `/manufacturers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manufacturer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upsert image
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertManufacturerImage: async (id: string, img?: Array<string>, file?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('upsertManufacturerImage', 'id', id)
            const localVarPath = `/manufacturers/{id}/image/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (img) {
                localVarQueryParameter['img'] = img.join(COLLECTION_FORMATS.csv);
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManufacturersApi - functional programming interface
 * @export
 */
export const ManufacturersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManufacturersApiAxiosParamCreator(configuration)
    return {
        /**
         * Add manufacturer
         * @param {Manufacturer} manufacturer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addManufacturer(manufacturer: Manufacturer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addManufacturer(manufacturer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete manufacturer
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteManufacturer(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteManufacturer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete image
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteManufacturerImage(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteManufacturerImage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get manufacturer details
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getManufacturer(id: string, img?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManufacturer(id, img, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List manufacturers
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listManufacturers(img?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManufacturerList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listManufacturers(img, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update manufacturer
         * @param {string} id ID
         * @param {Manufacturer} manufacturer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateManufacturer(id: string, manufacturer: Manufacturer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateManufacturer(id, manufacturer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upsert image
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertManufacturerImage(id: string, img?: Array<string>, file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upsertManufacturerImage(id, img, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ManufacturersApi - factory interface
 * @export
 */
export const ManufacturersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManufacturersApiFp(configuration)
    return {
        /**
         * Add manufacturer
         * @param {Manufacturer} manufacturer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addManufacturer(manufacturer: Manufacturer, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.addManufacturer(manufacturer, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete manufacturer
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteManufacturer(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteManufacturer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete image
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteManufacturerImage(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteManufacturerImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get manufacturer details
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManufacturer(id: string, img?: Array<string>, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.getManufacturer(id, img, options).then((request) => request(axios, basePath));
        },
        /**
         * List manufacturers
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listManufacturers(img?: Array<string>, options?: any): AxiosPromise<ManufacturerList> {
            return localVarFp.listManufacturers(img, options).then((request) => request(axios, basePath));
        },
        /**
         * Update manufacturer
         * @param {string} id ID
         * @param {Manufacturer} manufacturer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateManufacturer(id: string, manufacturer: Manufacturer, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.updateManufacturer(id, manufacturer, options).then((request) => request(axios, basePath));
        },
        /**
         * Upsert image
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertManufacturerImage(id: string, img?: Array<string>, file?: any, options?: any): AxiosPromise<Image> {
            return localVarFp.upsertManufacturerImage(id, img, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManufacturersApi - object-oriented interface
 * @export
 * @class ManufacturersApi
 * @extends {BaseAPI}
 */
export class ManufacturersApi extends BaseAPI {
    /**
     * Add manufacturer
     * @param {Manufacturer} manufacturer 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public addManufacturer(manufacturer: Manufacturer, options?: any) {
        return ManufacturersApiFp(this.configuration).addManufacturer(manufacturer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete manufacturer
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public deleteManufacturer(id: string, options?: any) {
        return ManufacturersApiFp(this.configuration).deleteManufacturer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete image
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public deleteManufacturerImage(id: string, options?: any) {
        return ManufacturersApiFp(this.configuration).deleteManufacturerImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get manufacturer details
     * @param {string} id ID
     * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public getManufacturer(id: string, img?: Array<string>, options?: any) {
        return ManufacturersApiFp(this.configuration).getManufacturer(id, img, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List manufacturers
     * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public listManufacturers(img?: Array<string>, options?: any) {
        return ManufacturersApiFp(this.configuration).listManufacturers(img, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update manufacturer
     * @param {string} id ID
     * @param {Manufacturer} manufacturer 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public updateManufacturer(id: string, manufacturer: Manufacturer, options?: any) {
        return ManufacturersApiFp(this.configuration).updateManufacturer(id, manufacturer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upsert image
     * @param {string} id ID
     * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public upsertManufacturerImage(id: string, img?: Array<string>, file?: any, options?: any) {
        return ManufacturersApiFp(this.configuration).upsertManufacturerImage(id, img, file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add product
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProduct: async (product: Product, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'product' is not null or undefined
            assertParamExists('addProduct', 'product', product)
            const localVarPath = `/products/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(product, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add product images
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {Array<any>} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProductImages: async (id: string, img?: Array<string>, file?: Array<any>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addProductImages', 'id', id)
            const localVarPath = `/products/{id}/images/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (img) {
                localVarQueryParameter['img'] = img.join(COLLECTION_FORMATS.csv);
            }

            if (file) {
                file.forEach((element) => {
                    localVarFormParams.append('file', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete product
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProduct', 'id', id)
            const localVarPath = `/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete product image
         * @param {string} id ID
         * @param {string} imageId Image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductImage: async (id: string, imageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProductImage', 'id', id)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('deleteProductImage', 'imageId', imageId)
            const localVarPath = `/products/{id}/images/{image_id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get product details
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {boolean} [resolve] The returned object should include related objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct: async (id: string, img?: Array<string>, resolve?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProduct', 'id', id)
            const localVarPath = `/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (img) {
                localVarQueryParameter['img'] = img.join(COLLECTION_FORMATS.csv);
            }

            if (resolve !== undefined) {
                localVarQueryParameter['resolve'] = resolve;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get product images
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductImages: async (id: string, img?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listProductImages', 'id', id)
            const localVarPath = `/products/{id}/images/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (img) {
                localVarQueryParameter['img'] = img.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List products
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts: async (img?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/products/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (img) {
                localVarQueryParameter['img'] = img.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update product
         * @param {string} id ID
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct: async (id: string, product: Product, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProduct', 'id', id)
            // verify required parameter 'product' is not null or undefined
            assertParamExists('updateProduct', 'product', product)
            const localVarPath = `/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(product, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update product image. In case the new order matches another image, the orders are swapped. Therefore, this call will return all impacted images (1 or 2). First the image on which the request was called and optionally second the swapped image.
         * @param {string} id ID
         * @param {string} imageId Image ID
         * @param {Image} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductImage: async (id: string, imageId: string, image: Image, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProductImage', 'id', id)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('updateProductImage', 'imageId', imageId)
            // verify required parameter 'image' is not null or undefined
            assertParamExists('updateProductImage', 'image', image)
            const localVarPath = `/products/{id}/images/{image_id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(image, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add product
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addProduct(product: Product, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addProduct(product, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add product images
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {Array<any>} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addProductImages(id: string, img?: Array<string>, file?: Array<any>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addProductImages(id, img, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete product
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProduct(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProduct(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete product image
         * @param {string} id ID
         * @param {string} imageId Image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductImage(id: string, imageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProductImage(id, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get product details
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {boolean} [resolve] The returned object should include related objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProduct(id: string, img?: Array<string>, resolve?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResolvedProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProduct(id, img, resolve, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get product images
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProductImages(id: string, img?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProductImages(id, img, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List products
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProducts(img?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProducts(img, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update product
         * @param {string} id ID
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProduct(id: string, product: Product, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProduct(id, product, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update product image. In case the new order matches another image, the orders are swapped. Therefore, this call will return all impacted images (1 or 2). First the image on which the request was called and optionally second the swapped image.
         * @param {string} id ID
         * @param {string} imageId Image ID
         * @param {Image} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProductImage(id: string, imageId: string, image: Image, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProductImage(id, imageId, image, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * Add product
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProduct(product: Product, options?: any): AxiosPromise<Product> {
            return localVarFp.addProduct(product, options).then((request) => request(axios, basePath));
        },
        /**
         * Add product images
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {Array<any>} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProductImages(id: string, img?: Array<string>, file?: Array<any>, options?: any): AxiosPromise<ImageList> {
            return localVarFp.addProductImages(id, img, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete product
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete product image
         * @param {string} id ID
         * @param {string} imageId Image ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductImage(id: string, imageId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProductImage(id, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get product details
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {boolean} [resolve] The returned object should include related objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(id: string, img?: Array<string>, resolve?: boolean, options?: any): AxiosPromise<ResolvedProduct> {
            return localVarFp.getProduct(id, img, resolve, options).then((request) => request(axios, basePath));
        },
        /**
         * Get product images
         * @param {string} id ID
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductImages(id: string, img?: Array<string>, options?: any): AxiosPromise<ImageList> {
            return localVarFp.listProductImages(id, img, options).then((request) => request(axios, basePath));
        },
        /**
         * List products
         * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts(img?: Array<string>, options?: any): AxiosPromise<ProductList> {
            return localVarFp.listProducts(img, options).then((request) => request(axios, basePath));
        },
        /**
         * Update product
         * @param {string} id ID
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(id: string, product: Product, options?: any): AxiosPromise<Product> {
            return localVarFp.updateProduct(id, product, options).then((request) => request(axios, basePath));
        },
        /**
         * Update product image. In case the new order matches another image, the orders are swapped. Therefore, this call will return all impacted images (1 or 2). First the image on which the request was called and optionally second the swapped image.
         * @param {string} id ID
         * @param {string} imageId Image ID
         * @param {Image} image 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductImage(id: string, imageId: string, image: Image, options?: any): AxiosPromise<ImageList> {
            return localVarFp.updateProductImage(id, imageId, image, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * Add product
     * @param {Product} product 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public addProduct(product: Product, options?: any) {
        return ProductsApiFp(this.configuration).addProduct(product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add product images
     * @param {string} id ID
     * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
     * @param {Array<any>} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public addProductImages(id: string, img?: Array<string>, file?: Array<any>, options?: any) {
        return ProductsApiFp(this.configuration).addProductImages(id, img, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete product
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProduct(id: string, options?: any) {
        return ProductsApiFp(this.configuration).deleteProduct(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete product image
     * @param {string} id ID
     * @param {string} imageId Image ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProductImage(id: string, imageId: string, options?: any) {
        return ProductsApiFp(this.configuration).deleteProductImage(id, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get product details
     * @param {string} id ID
     * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
     * @param {boolean} [resolve] The returned object should include related objects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProduct(id: string, img?: Array<string>, resolve?: boolean, options?: any) {
        return ProductsApiFp(this.configuration).getProduct(id, img, resolve, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get product images
     * @param {string} id ID
     * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public listProductImages(id: string, img?: Array<string>, options?: any) {
        return ProductsApiFp(this.configuration).listProductImages(id, img, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List products
     * @param {Array<string>} [img] Comma separated list of ImageConfig. Check ImageConfig for exact format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public listProducts(img?: Array<string>, options?: any) {
        return ProductsApiFp(this.configuration).listProducts(img, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update product
     * @param {string} id ID
     * @param {Product} product 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public updateProduct(id: string, product: Product, options?: any) {
        return ProductsApiFp(this.configuration).updateProduct(id, product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update product image. In case the new order matches another image, the orders are swapped. Therefore, this call will return all impacted images (1 or 2). First the image on which the request was called and optionally second the swapped image.
     * @param {string} id ID
     * @param {string} imageId Image ID
     * @param {Image} image 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public updateProductImage(id: string, imageId: string, image: Image, options?: any) {
        return ProductsApiFp(this.configuration).updateProductImage(id, imageId, image, options).then((request) => request(this.axios, this.basePath));
    }
}


