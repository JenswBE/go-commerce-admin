/* tslint:disable */
/* eslint-disable */
/**
 * GoCommerce
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof Category
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    description?: string;
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof Category
     */
    parent_id?: string;
    /**
     * Should be sorted ascending by this column
     * @type {number}
     * @memberof Category
     */
    order: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Category
     */
    product_ids?: Array<string>;
}
/**
 * 
 * @export
 * @interface CategoryAllOf
 */
export interface CategoryAllOf {
    /**
     * 
     * @type {string}
     * @memberof CategoryAllOf
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryAllOf
     */
    description?: string;
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof CategoryAllOf
     */
    parent_id?: string;
    /**
     * Should be sorted ascending by this column
     * @type {number}
     * @memberof CategoryAllOf
     */
    order: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CategoryAllOf
     */
    product_ids?: Array<string>;
}
/**
 * 
 * @export
 * @interface Header
 */
export interface Header {
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof Header
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface Manufacturer
 */
export interface Manufacturer {
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof Manufacturer
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Manufacturer
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Manufacturer
     */
    website_url?: string;
}
/**
 * 
 * @export
 * @interface ManufacturerAllOf
 */
export interface ManufacturerAllOf {
    /**
     * 
     * @type {string}
     * @memberof ManufacturerAllOf
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ManufacturerAllOf
     */
    website_url?: string;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof Product
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    description_short?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    description_long?: string;
    /**
     * Price in cents
     * @type {number}
     * @memberof Product
     */
    price?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Product
     */
    category_ids?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    manufacturer_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    status?: ProductStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    stock_count?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum ProductStatusEnum {
    Available = 'AVAILABLE',
    Archived = 'ARCHIVED'
}

/**
 * 
 * @export
 * @interface ProductAllOf
 */
export interface ProductAllOf {
    /**
     * 
     * @type {string}
     * @memberof ProductAllOf
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductAllOf
     */
    description_short?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductAllOf
     */
    description_long?: string;
    /**
     * Price in cents
     * @type {number}
     * @memberof ProductAllOf
     */
    price?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductAllOf
     */
    category_ids?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ProductAllOf
     */
    manufacturer_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductAllOf
     */
    status?: ProductAllOfStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductAllOf
     */
    stock_count?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum ProductAllOfStatusEnum {
    Available = 'AVAILABLE',
    Archived = 'ARCHIVED'
}

/**
 * 
 * @export
 * @interface TimestampedHeader
 */
export interface TimestampedHeader {
    /**
     * Compressed representation of ID
     * @type {string}
     * @memberof TimestampedHeader
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TimestampedHeader
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof TimestampedHeader
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface TimestampedHeaderAllOf
 */
export interface TimestampedHeaderAllOf {
    /**
     * 
     * @type {string}
     * @memberof TimestampedHeaderAllOf
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof TimestampedHeaderAllOf
     */
    updated_at?: string;
}

/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCategoriesGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete category
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCategoriesIdDelete: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminCategoriesIdDelete', 'id', id)
            const localVarPath = `/admin/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get category details
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCategoriesIdGet: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminCategoriesIdGet', 'id', id)
            const localVarPath = `/admin/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update category
         * @param {string} id ID
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCategoriesIdPut: async (id: string, category: Category, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminCategoriesIdPut', 'id', id)
            // verify required parameter 'category' is not null or undefined
            assertParamExists('adminCategoriesIdPut', 'category', category)
            const localVarPath = `/admin/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(category, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add category
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCategoriesPost: async (category: Category, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'category' is not null or undefined
            assertParamExists('adminCategoriesPost', 'category', category)
            const localVarPath = `/admin/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(category, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCategoriesGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/categories/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get category details
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCategoriesIdGet: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('publicCategoriesIdGet', 'id', id)
            const localVarPath = `/public/categories/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * List categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCategoriesGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCategoriesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete category
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCategoriesIdDelete(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCategoriesIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get category details
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCategoriesIdGet(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCategoriesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update category
         * @param {string} id ID
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCategoriesIdPut(id: string, category: Category, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCategoriesIdPut(id, category, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add category
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCategoriesPost(category: Category, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCategoriesPost(category, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicCategoriesGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicCategoriesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get category details
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicCategoriesIdGet(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicCategoriesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoriesApiFp(configuration)
    return {
        /**
         * List categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCategoriesGet(options?: any): AxiosPromise<Array<Category>> {
            return localVarFp.adminCategoriesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete category
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCategoriesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.adminCategoriesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get category details
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCategoriesIdGet(id: string, options?: any): AxiosPromise<Category> {
            return localVarFp.adminCategoriesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update category
         * @param {string} id ID
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCategoriesIdPut(id: string, category: Category, options?: any): AxiosPromise<Category> {
            return localVarFp.adminCategoriesIdPut(id, category, options).then((request) => request(axios, basePath));
        },
        /**
         * Add category
         * @param {Category} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCategoriesPost(category: Category, options?: any): AxiosPromise<Category> {
            return localVarFp.adminCategoriesPost(category, options).then((request) => request(axios, basePath));
        },
        /**
         * List categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCategoriesGet(options?: any): AxiosPromise<Array<Category>> {
            return localVarFp.publicCategoriesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get category details
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicCategoriesIdGet(id: string, options?: any): AxiosPromise<Category> {
            return localVarFp.publicCategoriesIdGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
    /**
     * List categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public adminCategoriesGet(options?: any) {
        return CategoriesApiFp(this.configuration).adminCategoriesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete category
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public adminCategoriesIdDelete(id: string, options?: any) {
        return CategoriesApiFp(this.configuration).adminCategoriesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get category details
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public adminCategoriesIdGet(id: string, options?: any) {
        return CategoriesApiFp(this.configuration).adminCategoriesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update category
     * @param {string} id ID
     * @param {Category} category 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public adminCategoriesIdPut(id: string, category: Category, options?: any) {
        return CategoriesApiFp(this.configuration).adminCategoriesIdPut(id, category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add category
     * @param {Category} category 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public adminCategoriesPost(category: Category, options?: any) {
        return CategoriesApiFp(this.configuration).adminCategoriesPost(category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public publicCategoriesGet(options?: any) {
        return CategoriesApiFp(this.configuration).publicCategoriesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get category details
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public publicCategoriesIdGet(id: string, options?: any) {
        return CategoriesApiFp(this.configuration).publicCategoriesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImagesApi - axios parameter creator
 * @export
 */
export const ImagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Upload image for object (Category, Manufacturer, ...)
         * @param {string} id ID
         * @param {any} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminImagesIdPut: async (id: string, image?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminImagesIdPut', 'id', id)
            const localVarPath = `/admin/images/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImagesApi - functional programming interface
 * @export
 */
export const ImagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Upload image for object (Category, Manufacturer, ...)
         * @param {string} id ID
         * @param {any} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminImagesIdPut(id: string, image?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminImagesIdPut(id, image, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImagesApi - factory interface
 * @export
 */
export const ImagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImagesApiFp(configuration)
    return {
        /**
         * Upload image for object (Category, Manufacturer, ...)
         * @param {string} id ID
         * @param {any} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminImagesIdPut(id: string, image?: any, options?: any): AxiosPromise<void> {
            return localVarFp.adminImagesIdPut(id, image, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImagesApi - object-oriented interface
 * @export
 * @class ImagesApi
 * @extends {BaseAPI}
 */
export class ImagesApi extends BaseAPI {
    /**
     * Upload image for object (Category, Manufacturer, ...)
     * @param {string} id ID
     * @param {any} [image] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public adminImagesIdPut(id: string, image?: any, options?: any) {
        return ImagesApiFp(this.configuration).adminImagesIdPut(id, image, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ManufacturersApi - axios parameter creator
 * @export
 */
export const ManufacturersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List manufacturers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminManufacturersGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/manufacturers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete manufacturer
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminManufacturersIdDelete: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminManufacturersIdDelete', 'id', id)
            const localVarPath = `/admin/manufacturers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get manufacturer details
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminManufacturersIdGet: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminManufacturersIdGet', 'id', id)
            const localVarPath = `/admin/manufacturers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update manufacturer
         * @param {string} id ID
         * @param {Manufacturer} manufacturer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminManufacturersIdPut: async (id: string, manufacturer: Manufacturer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminManufacturersIdPut', 'id', id)
            // verify required parameter 'manufacturer' is not null or undefined
            assertParamExists('adminManufacturersIdPut', 'manufacturer', manufacturer)
            const localVarPath = `/admin/manufacturers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manufacturer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add manufacturer
         * @param {Manufacturer} manufacturer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminManufacturersPost: async (manufacturer: Manufacturer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'manufacturer' is not null or undefined
            assertParamExists('adminManufacturersPost', 'manufacturer', manufacturer)
            const localVarPath = `/admin/manufacturers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manufacturer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List manufacturers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicManufacturersGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/manufacturers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get manufacturer details
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicManufacturersIdGet: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('publicManufacturersIdGet', 'id', id)
            const localVarPath = `/public/manufacturers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManufacturersApi - functional programming interface
 * @export
 */
export const ManufacturersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManufacturersApiAxiosParamCreator(configuration)
    return {
        /**
         * List manufacturers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminManufacturersGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Manufacturer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminManufacturersGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete manufacturer
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminManufacturersIdDelete(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminManufacturersIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get manufacturer details
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminManufacturersIdGet(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminManufacturersIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update manufacturer
         * @param {string} id ID
         * @param {Manufacturer} manufacturer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminManufacturersIdPut(id: string, manufacturer: Manufacturer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminManufacturersIdPut(id, manufacturer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add manufacturer
         * @param {Manufacturer} manufacturer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminManufacturersPost(manufacturer: Manufacturer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminManufacturersPost(manufacturer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List manufacturers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicManufacturersGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Manufacturer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicManufacturersGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get manufacturer details
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicManufacturersIdGet(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicManufacturersIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ManufacturersApi - factory interface
 * @export
 */
export const ManufacturersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManufacturersApiFp(configuration)
    return {
        /**
         * List manufacturers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminManufacturersGet(options?: any): AxiosPromise<Array<Manufacturer>> {
            return localVarFp.adminManufacturersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete manufacturer
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminManufacturersIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.adminManufacturersIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get manufacturer details
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminManufacturersIdGet(id: string, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.adminManufacturersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update manufacturer
         * @param {string} id ID
         * @param {Manufacturer} manufacturer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminManufacturersIdPut(id: string, manufacturer: Manufacturer, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.adminManufacturersIdPut(id, manufacturer, options).then((request) => request(axios, basePath));
        },
        /**
         * Add manufacturer
         * @param {Manufacturer} manufacturer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminManufacturersPost(manufacturer: Manufacturer, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.adminManufacturersPost(manufacturer, options).then((request) => request(axios, basePath));
        },
        /**
         * List manufacturers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicManufacturersGet(options?: any): AxiosPromise<Array<Manufacturer>> {
            return localVarFp.publicManufacturersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get manufacturer details
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicManufacturersIdGet(id: string, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.publicManufacturersIdGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManufacturersApi - object-oriented interface
 * @export
 * @class ManufacturersApi
 * @extends {BaseAPI}
 */
export class ManufacturersApi extends BaseAPI {
    /**
     * List manufacturers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public adminManufacturersGet(options?: any) {
        return ManufacturersApiFp(this.configuration).adminManufacturersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete manufacturer
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public adminManufacturersIdDelete(id: string, options?: any) {
        return ManufacturersApiFp(this.configuration).adminManufacturersIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get manufacturer details
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public adminManufacturersIdGet(id: string, options?: any) {
        return ManufacturersApiFp(this.configuration).adminManufacturersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update manufacturer
     * @param {string} id ID
     * @param {Manufacturer} manufacturer 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public adminManufacturersIdPut(id: string, manufacturer: Manufacturer, options?: any) {
        return ManufacturersApiFp(this.configuration).adminManufacturersIdPut(id, manufacturer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add manufacturer
     * @param {Manufacturer} manufacturer 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public adminManufacturersPost(manufacturer: Manufacturer, options?: any) {
        return ManufacturersApiFp(this.configuration).adminManufacturersPost(manufacturer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List manufacturers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public publicManufacturersGet(options?: any) {
        return ManufacturersApiFp(this.configuration).publicManufacturersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get manufacturer details
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManufacturersApi
     */
    public publicManufacturersIdGet(id: string, options?: any) {
        return ManufacturersApiFp(this.configuration).publicManufacturersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProductsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/products/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete product
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProductsIdDelete: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminProductsIdDelete', 'id', id)
            const localVarPath = `/admin/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get product details
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProductsIdGet: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminProductsIdGet', 'id', id)
            const localVarPath = `/admin/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update product
         * @param {string} id ID
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProductsIdPut: async (id: string, product: Product, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminProductsIdPut', 'id', id)
            // verify required parameter 'product' is not null or undefined
            assertParamExists('adminProductsIdPut', 'product', product)
            const localVarPath = `/admin/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(product, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add product
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProductsPost: async (product: Product, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'product' is not null or undefined
            assertParamExists('adminProductsPost', 'product', product)
            const localVarPath = `/admin/products/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(product, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicProductsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/products/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get product details
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicProductsIdGet: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('publicProductsIdGet', 'id', id)
            const localVarPath = `/public/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * List products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminProductsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Product>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminProductsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete product
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminProductsIdDelete(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminProductsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get product details
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminProductsIdGet(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminProductsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update product
         * @param {string} id ID
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminProductsIdPut(id: string, product: Product, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminProductsIdPut(id, product, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add product
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminProductsPost(product: Product, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminProductsPost(product, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicProductsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Product>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicProductsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get product details
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicProductsIdGet(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicProductsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * List products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProductsGet(options?: any): AxiosPromise<Array<Product>> {
            return localVarFp.adminProductsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete product
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProductsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.adminProductsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get product details
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProductsIdGet(id: string, options?: any): AxiosPromise<Product & object> {
            return localVarFp.adminProductsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update product
         * @param {string} id ID
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProductsIdPut(id: string, product: Product, options?: any): AxiosPromise<Product> {
            return localVarFp.adminProductsIdPut(id, product, options).then((request) => request(axios, basePath));
        },
        /**
         * Add product
         * @param {Product} product 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProductsPost(product: Product, options?: any): AxiosPromise<Product> {
            return localVarFp.adminProductsPost(product, options).then((request) => request(axios, basePath));
        },
        /**
         * List products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicProductsGet(options?: any): AxiosPromise<Array<Product>> {
            return localVarFp.publicProductsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get product details
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicProductsIdGet(id: string, options?: any): AxiosPromise<Product & object> {
            return localVarFp.publicProductsIdGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * List products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public adminProductsGet(options?: any) {
        return ProductsApiFp(this.configuration).adminProductsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete product
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public adminProductsIdDelete(id: string, options?: any) {
        return ProductsApiFp(this.configuration).adminProductsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get product details
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public adminProductsIdGet(id: string, options?: any) {
        return ProductsApiFp(this.configuration).adminProductsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update product
     * @param {string} id ID
     * @param {Product} product 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public adminProductsIdPut(id: string, product: Product, options?: any) {
        return ProductsApiFp(this.configuration).adminProductsIdPut(id, product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add product
     * @param {Product} product 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public adminProductsPost(product: Product, options?: any) {
        return ProductsApiFp(this.configuration).adminProductsPost(product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public publicProductsGet(options?: any) {
        return ProductsApiFp(this.configuration).publicProductsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get product details
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public publicProductsIdGet(id: string, options?: any) {
        return ProductsApiFp(this.configuration).publicProductsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}


